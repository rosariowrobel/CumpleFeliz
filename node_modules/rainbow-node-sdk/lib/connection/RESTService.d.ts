/// <reference types="node" />
import { RESTTelephony } from "./RestServices/RESTTelephony";
import { HTTPService } from "./HttpService";
import EventEmitter = NodeJS.EventEmitter;
import { Logger } from "../common/Logger";
import { ROOMROLE } from "../services/S2SService";
declare enum MEDIATYPE {
    WEBRTC = "webrtc",
    PstnAudio = "pstnAudio",
    WEBRTCSHARINGONLY = "webrtcSharingOnly"
}
declare class GuestParams {
    loginEmail: string;
    password: string;
    temporaryToken: string;
    invitationId: string;
    joinCompanyInvitationId: string;
    joinCompanyLinkId: string;
    openInviteId: string;
    isInitialized: boolean;
    firstName: string;
    lastName: string;
    nickName: string;
    title: string;
    jobTitle: string;
    department: string;
    emails: {
        email: string;
        type: string;
    };
    phoneNumbers: Array<{
        number: string;
        country: string;
        type: string;
        deviceType: string;
        isVisibleByOthers: boolean;
    }>;
    country: string;
    state: string;
    language: string;
    timezone: string;
    visibility: string;
    customData: {
        key1: string;
        key2: string;
    };
    constructor(_loginEmail?: string, _password?: string, _temporaryToken?: string, _invitationId?: string, _joinCompanyInvitationId?: string, _joinCompanyLinkId?: string, _openInviteId?: string, _isInitialized?: boolean, _firstName?: string, _lastName?: string, _nickName?: string, _title?: string, _jobTitle?: string, _department?: string, _emails?: {
        email: string;
        type: string;
    }, _phoneNumbers?: Array<any>, _country?: string, _state?: string, _language?: string, _timezone?: string, _visibility?: string, _customData?: any);
    getUrlParam(): any;
}
declare class RESTService {
    http: HTTPService;
    account: any;
    app: any;
    token: any;
    renewTokenInterval: any;
    auth: any;
    _credentials: any;
    _application: any;
    loginEmail: any;
    eventEmitter: EventEmitter;
    logger: Logger;
    currentAttempt: any;
    attempt_succeeded_callback: any;
    attempt_failed_callback: any;
    attempt_promise_resolver: any;
    _isOfficialRainbow: any;
    maxAttemptToReconnect: any;
    fibonacciStrategy: any;
    reconnectDelay: any;
    restTelephony: RESTTelephony;
    getRequestHeader: any;
    getRequestHeaderWithRange: any;
    getPostHeaderWithRange: any;
    getLoginHeader: any;
    getDefaultHeader: any;
    applicationToken: string;
    getPostHeader: any;
    connectionS2SInfo: any;
    private reconnectInProgress;
    constructor(_credentials: any, _application: any, _isOfficialRainbow: any, evtEmitter: EventEmitter, _logger: Logger);
    get userId(): any;
    get loggedInUser(): any;
    start(http: any): Promise<void>;
    stop(): Promise<unknown>;
    signin(token: any): Promise<unknown>;
    setconnectionS2SInfo(_connectionS2SInfo: any): void;
    askTokenOnBehalf(loginEmail: any, password: any): Promise<unknown>;
    signout(): Promise<unknown>;
    startTokenSurvey(): void;
    _renewAuthToken(): void;
    getContacts(): Promise<unknown>;
    removeContactFromRoster(dbId: any): Promise<unknown>;
    getContactInformationByJID(jid: any): Promise<unknown>;
    getContactInformationByID(id: any): Promise<unknown>;
    getContactInformationByLoginEmail(email: any): Promise<[any]>;
    getServerFavorites(): Promise<unknown>;
    addServerFavorite(peerId: string, type: string): Promise<unknown>;
    removeServerFavorite(favoriteId: string): Promise<unknown>;
    /**
     * ACCEPT INVITATION
     * Used by SDK (public)
     * Warning when modifying this method
     */
    acceptInvitation(invitation: any): Promise<unknown>;
    /**
     * DECLINE INVITATION
     * Used by SDK (public)
     * Warning when modifying this method
     */
    declineInvitation(invitation: any): Promise<unknown>;
    /**
     * SEND INVITATION
     * Used by SDK (public)
     * Warning when modifying this method
     */
    joinContactInvitation(contact: any): Promise<unknown>;
    joinContacts(contact: any, contactIds: any, presence: any): Promise<unknown>;
    getInvitationById(invitationId: any): Promise<unknown>;
    getGroups(): Promise<unknown>;
    getGroup(groupId: any): Promise<unknown>;
    setFavoriteGroup(group: any, favorite: any): Promise<unknown>;
    createGroup(name: any, comment: any, isFavorite: any): Promise<unknown>;
    deleteGroup(groupId: any): Promise<unknown>;
    updateGroupName(groupId: any, name: any): Promise<unknown>;
    addUserInGroup(contactId: any, groupId: any): Promise<unknown>;
    removeUserFromGroup(contactId: any, groupId: any): Promise<unknown>;
    getBots(): Promise<unknown>;
    createBubble(name: any, description: any, withHistory: any): Promise<unknown>;
    setBubbleVisibility(bubbleId: any, visibility: any): Promise<unknown>;
    setBubbleTopic(bubbleId: any, topic: any): Promise<unknown>;
    setBubbleName(bubbleId: any, name: any): Promise<unknown>;
    getBubbles(): Promise<unknown>;
    getBubble(bubbleId: any): Promise<unknown>;
    getBubbleByJid(bubbleJid: any): Promise<unknown>;
    setBubbleCustomData(bubbleId: any, customData: any): Promise<unknown>;
    inviteContactToBubble(contactId: any, bubbleId: any, asModerator: any, withInvitation: any, reason: any): Promise<unknown>;
    inviteContactsByEmailsToBubble(contactsEmails: any, bubbleId: any): Promise<unknown>;
    getRoomUsers(bubbleId: any, options?: any): Promise<unknown>;
    promoteContactInBubble(contactId: any, bubbleId: any, asModerator: any): Promise<unknown>;
    changeBubbleOwner(bubbleId: any, contactId: any): Promise<unknown>;
    archiveBubble(bubbleId: any): Promise<unknown>;
    leaveBubble(bubbleId: any, bubbleStatus: any): Promise<unknown>;
    deleteBubble(bubbleId: any): Promise<unknown>;
    removeInvitationOfContactToBubble(contactId: any, bubbleId: any): Promise<unknown>;
    unsubscribeContactFromBubble(contactId: any, bubbleId: any): Promise<unknown>;
    acceptInvitationToJoinBubble(bubbleId: any): Promise<unknown>;
    declineInvitationToJoinBubble(bubbleId: any): Promise<unknown>;
    inviteUser(email: any, companyId: any, language: any, message: any): Promise<unknown>;
    setAvatarRoom(bubbleid: any, binaryData: any): Promise<unknown>;
    deleteAvatarRoom(roomId: any): Promise<unknown>;
    /**
     * Method retrieveWebConferences
     * @public
     * @param {string} mediaType mediaType of conference to retrieve. Default: this.MEDIATYPE.WEBRTC
     * @returns {ng.IPromise<any>} a promise that resolves when conference are reterived
     * @memberof WebConferenceService
     */
    retrieveWebConferences(mediaType?: string): Promise<any>;
    createUser(email: any, password: any, firstname: any, lastname: any, companyId: any, language: any, isAdmin: any, roles: any): Promise<unknown>;
    createGuestUser(firstname: any, lastname: any, language: any, timeToLive: any): Promise<unknown>;
    changePassword(password: any, userId: any): Promise<unknown>;
    updateInformation(objData: any, userId: any): Promise<unknown>;
    deleteUser(userId: any): Promise<unknown>;
    createFileDescriptor(name: any, extension: any, size: any, viewers: any): Promise<unknown>;
    deleteFileDescriptor(fileId: any): Promise<unknown>;
    retrieveFileDescriptors(format: any, limit: any, offset: any, viewerId: any): Promise<unknown>;
    retrieveFilesReceivedFromPeer(userId: any, peerId: any): Promise<unknown>;
    retrieveReceivedFilesForRoomOrViewer(roomId: any): Promise<unknown>;
    retrieveOneFileDescriptor(fileId: any): Promise<unknown>;
    retrieveUserConsumption(): Promise<unknown>;
    deleteFileViewer(viewerId: any, fileId: any): Promise<unknown>;
    addFileViewer(fileId: any, viewerId: any, viewerType: any): Promise<unknown>;
    getPartialDataFromServer(url: any, minRange: any, maxRange: any, index: any): Promise<unknown>;
    getFileFromUrl(url: any): Promise<unknown>;
    getBlobFromUrl(url: any): Promise<unknown>;
    uploadAFile(fileId: any, buffer: any): Promise<unknown>;
    uploadAStream(fileId: any, stream: any): Promise<unknown>;
    sendPartialDataToServer(fileId: any, file: any, index: any): Promise<unknown>;
    sendPartialFileCompletion(fileId: any): Promise<unknown>;
    getServerCapabilities(): Promise<unknown>;
    getUserSettings(): Promise<unknown>;
    updateUserSettings(settings: any): Promise<unknown>;
    getAllCompanies(): Promise<unknown>;
    getAllUsers(format?: string, offset?: number, limit?: number, sortField?: string): Promise<unknown>;
    getContactInfos(userId: any): Promise<unknown>;
    putContactInfos(userId: any, infos: any): Promise<unknown>;
    createCompany(name: any, country: any, state: any, offerType: any): Promise<unknown>;
    getCompany(companyId: any): Promise<unknown>;
    deleteCompany(companyId: any): Promise<unknown>;
    setVisibilityForCompany(companyId: any, visibleByCompanyId: any): Promise<unknown>;
    createPublicChannel(name: any, topic: any, category: string, visibility: any, max_items: any, max_payload_size: any): Promise<unknown>;
    deleteChannel(channelId: any): Promise<unknown>;
    findChannels(name: any, topic: any, category: any, limit: any, offset: any, sortField: any, sortOrder: any): Promise<unknown>;
    getChannels(): Promise<unknown>;
    getChannel(id: any): Promise<unknown>;
    publishMessage(channelId: any, message: any, title: any, url: any, imagesIds: any, type: any): Promise<unknown>;
    private chewReceivedItems;
    /**
     * Get latests message from channel
     */
    getLatestMessages(maxMessages: number, beforeDate?: Date, afterDate?: Date): Promise<unknown>;
    subscribeToChannel(channelId: any): Promise<unknown>;
    unsubscribeToChannel(channelId: any): Promise<unknown>;
    updateChannel(channelId: any, title: any, visibility: any, max_items: any, max_payload_size: any, channelName: any, mode: any): Promise<unknown>;
    uploadChannelAvatar(channelId: string, avatar: any, avatarSize: number, fileType: string): Promise<any>;
    deleteChannelAvatar(channelId: string): Promise<any>;
    getChannelUsers(channelId: any, options: any): Promise<unknown>;
    deleteAllUsersFromChannel(channelId: any): Promise<unknown>;
    updateChannelUsers(channelId: any, users: any): Promise<unknown>;
    getChannelMessages(channelId: any): Promise<unknown>;
    likeItem(channelId: any, itemId: any, appreciation: any): Promise<unknown>;
    getDetailedAppreciations(channelId: any, itemId: any): Promise<unknown>;
    /**
     * Delete item from a channel
     */
    deleteChannelMessage(channelId: any, itemId: any): Promise<unknown>;
    getServerProfiles(): Promise<unknown>;
    getServerProfilesFeatures(): Promise<unknown>;
    makeCall(contact: any, phoneInfo: any): Promise<unknown>;
    releaseCall(call: any): Promise<unknown>;
    makeConsultationCall(callId: any, contact: any, phoneInfo: any): Promise<unknown>;
    answerCall(call: any): Promise<unknown>;
    holdCall(call: any): Promise<unknown>;
    retrieveCall(call: any): Promise<unknown>;
    deflectCallToVM(call: any, VMInfos: any): Promise<unknown>;
    deflectCall(call: any, calleeInfos: any): Promise<unknown>;
    transfertCall(activeCall: any, heldCall: any): Promise<unknown>;
    conferenceCall(activeCall: any, heldCall: any): Promise<unknown>;
    forwardToDevice(contact: any, phoneInfo: any): Promise<unknown>;
    getForwardStatus(): Promise<unknown>;
    getNomadicStatus(): Promise<unknown>;
    nomadicLogin(data: any): Promise<unknown>;
    sendDtmf(callId: any, deviceId: any, data: any): Promise<unknown>;
    logon(endpointTel: any, agentId: any, password: any, groupId: any): Promise<unknown>;
    logoff(endpointTel: any, agentId: any, password: any, groupId: any): Promise<unknown>;
    withdrawal(agentId: any, groupId: any, status: any): Promise<unknown>;
    wrapup(agentId: any, groupId: any, password: any, status: any): Promise<unknown>;
    getRainbowNodeSdkPackagePublishedInfos(): Promise<unknown>;
    getServerConversations(format?: String): Promise<unknown>;
    createServerConversation(conversation: any): Promise<unknown>;
    deleteServerConversation(conversationId: any): Promise<unknown>;
    updateServerConversation(conversationId: any, mute: any): Promise<unknown>;
    sendConversationByEmail(conversationId: any): Promise<unknown>;
    ackAllMessages(conversationId: any): Promise<unknown>;
    getAllSentInvitations(): Promise<unknown>;
    getServerInvitation(invitationId: any): Promise<unknown>;
    sendInvitationByEmail(email: any, lang: any, customMessage: any): Promise<unknown>;
    cancelOneSendInvitation(invitation: any): Promise<unknown>;
    reSendInvitation(invitationId: any): Promise<unknown>;
    sendInvitationsParBulk(listOfMails: any): Promise<unknown>;
    getAllReceivedInvitations(): Promise<unknown>;
    get(url: any, token: any): Promise<unknown>;
    post(url: any, token: any, data: any, contentType: any): Promise<unknown>;
    put(url: any, token: any, data: any): Promise<unknown>;
    delete(url: any, token: any): Promise<unknown>;
    checkEveryPortals(): Promise<[void, void, void, void, void, void] | {
        status: string;
    }>;
    checkPortalHealth(currentAttempt: any): Promise<unknown>;
    attemptToReconnect(reconnectDelay: any, currentAttempt: any): void;
    get_attempt_succeeded_callback(resolve?: any): any;
    get_attempt_failed_callback(reject?: any): any;
    reconnect(): Promise<unknown>;
    listConnectionsS2S(): Promise<any>;
    sendS2SPresence(obj: any): Promise<any>;
    deleteConnectionsS2S(connexions: any): Promise<any>;
    loginS2S(callback_url: any): Promise<any>;
    infoS2S(s2sConnectionId: any): Promise<any>;
    setS2SConnection(connectionId: any): Promise<any>;
    sendS2SMessageInConversation(conversationId: any, msg: any): Promise<any>;
    getS2SServerConversation(conversationId: any): Promise<any>;
    checkS2Sconnection(): Promise<any>;
    /**
     *
     * @param roomid
     * @param {string} role Enum: "member" "moderator" of your role in this room

     */
    joinS2SRoom(roomid: any, role: ROOMROLE): Promise<any>;
    markMessageAsRead(conversationId: any, messageId: any): Promise<unknown>;
    /**
     *
     * @param {string} userId id of to get all openInviteId belonging to this user. If not setted the connected user is used.
     * @param {string} type type optionnel to get the public link of personal rooms type query parameter used with personal_audio_room or personal_video_room or default.
     * @param {string} roomId id optionnel to get the public link for a given roomId, managed by the userId roomId
     * @return {Promise<any>}
     */
    getAllOpenInviteIdPerRoomOfAUser(userId?: string, type?: string, roomId?: string): Promise<Array<any>>;
    generateNewPublicUrl(bubbleId: any): Promise<unknown>;
    removePublicUrl(bubbleId: any): Promise<unknown>;
    createPublicUrl(bubbleId: any): Promise<unknown>;
    registerGuest(guest: GuestParams): Promise<unknown>;
    joinConference(webPontConferenceId: any, role?: string): Promise<unknown>;
    getRoomByConferenceEndpointId(conferenceEndpointId: any): Promise<unknown>;
    conferenceStart(roomId: string, conferenceId: string, mediaType: MEDIATYPE): Promise<unknown>;
    conferenceStop(conferenceId: string, mediaType: MEDIATYPE, roomId: string): Promise<unknown>;
    conferenceJoin(conferenceId: any, mediaType: any, asModerator: boolean, muted: boolean, phoneNumber: string, country: string): Promise<unknown>;
    conferenceDropParticipant(conferenceId: any, mediaType: any, participantId: any): Promise<unknown>;
    personalConferenceGetPhoneNumbers(): Promise<unknown>;
    personalConferenceGetPassCodes(personalConferenceConfEndpointId: any): Promise<unknown>;
    personalConferenceResetPassCodes(personalConferenceConfEndpointId: any): Promise<unknown>;
    personalConferenceRename(personalConferenceConfEndpointId: string, name: string): Promise<unknown>;
    askConferenceSnapshot(conferenceId: string, type: MEDIATYPE): Promise<unknown>;
    conferenceModeratorAction(conferenceId: string, mediaType: MEDIATYPE, action: string): Promise<unknown>;
    conferenceModeratorActionOnParticipant(conferenceId: string, mediaType: MEDIATYPE, participantId: string, action: string): Promise<unknown>;
    retrieveAllConferences(scheduled: any): Promise<unknown>;
    retrieveAllCompanyOffers(companyId: string): Promise<unknown>;
    retrieveAllCompanySubscriptions(companyId: string): Promise<unknown>;
    subscribeCompanyToOffer(companyId: string, offerId: string, maxNumberUsers?: number, autoRenew?: boolean): Promise<unknown>;
    unSubscribeCompanyToSubscription(companyId: string, subscriptionId: string): Promise<unknown>;
    subscribeUserToSubscription(userId: string, subscriptionId: string): Promise<unknown>;
    unSubscribeUserToSubscription(userId: string, subscriptionId: string): Promise<unknown>;
}
export { RESTService, MEDIATYPE, GuestParams };
