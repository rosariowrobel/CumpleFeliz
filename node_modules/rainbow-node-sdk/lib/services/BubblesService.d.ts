/// <reference types="node" />
import { List } from "ts-generic-collections-linq";
import { MEDIATYPE } from "../connection/RESTService";
import { Bubble } from "../common/models/Bubble";
import { EventEmitter } from "events";
import { Logger } from "../common/Logger";
import { Core } from "../Core";
import { Contact } from "../common/models/Contact";
import { ConferenceSession } from "../common/models/ConferenceSession";
import { ConferencePassCodes } from "../common/models/ConferencePassCodes";
export {};
declare class Bubbles {
    private _xmpp;
    private _rest;
    private _bubbles;
    private _eventEmitter;
    private _logger;
    ready: boolean;
    private readonly _startConfig;
    private avatarDomain;
    private _contacts;
    private _profileService;
    private _options;
    private _s2s;
    private _presence;
    private _useXMPP;
    private _useS2S;
    private _personalConferenceBubbleId;
    private _personalConferenceConfEndpointId;
    private _conferenceEndpoints;
    private _conferencesSessionById;
    private _linkConferenceAndBubble;
    private _webrtcConferenceId;
    _webConferenceRoom: any;
    private _protocol;
    private _host;
    private _port;
    get startConfig(): {
        start_up: boolean;
        optional: boolean;
    };
    constructor(_eventEmitter: EventEmitter, _http: any, _logger: Logger, _startConfig: any);
    start(_options: any, _core: Core): Promise<unknown>;
    stop(): Promise<unknown>;
    /**
     * @public
     * @method createBubble
     * @instance
     * @description
     *  Create a new bubble
     * @param {string} name  The name of the bubble to create
     * @param {string} description  The description of the bubble to create
     * @param {boolean} withHistory If true, a newcomer will have the complete messages history since the beginning of the bubble. False if omitted
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - Bubble object, else an ErrorManager object
     * @category async
     */
    createBubble(name: any, description: any, withHistory: any): Promise<unknown>;
    /**
     * @public
     * @method isBubbleClosed
     * @instance
     * @param {Bubble} bubble  The bubble to check
     * @return {boolean} True if the bubble is closed
     * @description
     *  Check if the bubble is closed or not.
     */
    isBubbleClosed(bubble: any): boolean;
    /**
     * @public
     * @method
     * @instance
     * @description
     *    Delete all existing owned bubbles <br/>
     *    Return a promise
     * @return {Object} Nothing or an error object depending on the result
     */
    deleteAllBubbles(): void;
    /**
     * @public
     * @method deleteBubble
     * @instance
     * @param {Bubble} bubble  The bubble to delete
     * @description
     *  Delete a owned bubble. When the owner deletes a bubble, the bubble and its content is no more accessible by all participants.
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble removed, else an ErrorManager object
     * @category async
     */
    deleteBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method closeAndDeleteBubble
     * @instance
     * @param {Bubble} bubble  The bubble to close + delete
     * @description
     *  Delete a owned bubble. When the owner deletes a bubble, the bubble and its content is no more accessible by all participants.
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble removed, else an ErrorManager object
     * @category async
     */
    closeAndDeleteBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method closeBubble
     * @instance
     * @param {Bubble} bubble The Bubble to close
     * @description
     *  Close a owned bubble. When the owner closes a bubble, the bubble is archived and only accessible in read only mode for all participants.
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble closed, else an ErrorManager object
     * @category async
     */
    closeBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method archiveBubble
     * @instance
     * @param {Bubble} bubble  The bubble to archive
     * @description
     *  Archive  a bubble.
     *  This API allows to close the room in one step. The other alternative is to change the status for each room users not deactivated yet.
     *  All users currently having the status 'invited' or 'accepted' will receive a message/stanza .
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The operation result
     * @category async
     */
    archiveBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method leaveBubble
     * @instance
     * @param {Bubble} bubble  The bubble to leave
     * @description
     *  Leave a bubble. If the connected user is a moderator, an other moderator should be still present in order to leave this bubble.
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The operation result
     * @category async
     */
    leaveBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method getUsersFromBubble
     * @instance
     * @param {Bubble} bubble           The bubble
     * @param {Object} options          The criterias to select the users to retrieve
     * format : Allows to retrieve more or less user details in response, besides specifics data about room users like (privilege, status and additionDate)
     * - small: userId loginEmail displayName jid_im
     * - medium: userId loginEmail displayName jid_im status additionDate privilege firstName lastName companyId companyName
     * - full: userId loginEmail displayName jid_im status additionDate privilege firstName lastName nickName title jobTitle emails country language timezone companyId companyName roles adminType
     * sortField : Sort items list based on the given field
     * privilege : Allows to filter users list on the privilege type provided in this option.
     * limit : Allow to specify the number of items to retrieve.
     * offset : Allow to specify the position of first item to retrieve (first item if not specified). Warning: if offset > total, no results are returned.
     * sortOrder : Specify order when sorting items list. Available values -1, 1 (default)
     * @description
     *  Get a list of users in a bubble filtered by criterias.
     * @async
     * @return {Promise<Array, ErrorManager>}
     */
    getUsersFromBubble(bubble: any, options?: Object): Promise<unknown>;
    /**
     * @public
     * @method getStatusForConnectedUserInBubble
     * @instance
     * @param {Bubble} bubble           The bubble
     * @description
     *  Get the status of the connected user in a bubble
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     */
    getStatusForConnectedUserInBubble(bubble: any): any;
    /**
     * @public
     * @method inviteContactToBubble
     * @instance
     * @param {Contact} contact         The contact to invite
     * @param {Bubble} bubble           The bubble
     * @param {boolean} isModerator     True to add a contact as a moderator of the bubble
     * @param {boolean} withInvitation  If true, the contact will receive an invitation and will have to accept it before entering the bubble. False to force the contact directly in the bubble without sending an invitation.
     * @param {string} reason        The reason of the invitation (optional)
     * @description
     *  Invite a contact in a bubble
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble updated with the new invitation
     * @category async
     */
    inviteContactToBubble(contact: any, bubble: any, isModerator: any, withInvitation: any, reason: any): Promise<unknown>;
    /**
     * @public
     * @method inviteContactsByEmailsToBubble
     * @instance
     * @param {Contact} contactsEmails         The contacts email tab to invite
     * @param {Bubble} bubble           The bubble
     * @description
     *  Invite a list of contacts by emails in a bubble
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble updated with the new invitation
     * @category async
     */
    inviteContactsByEmailsToBubble(contactsEmails: any, bubble: any): Promise<unknown>;
    /**
     * @public
     * @method promoteContactInBubble
     * @instance
     * @param {Contact} contact         The contact to promote or downgraded
     * @param {Bubble} bubble           The bubble
     * @param {boolean} isModerator     True to promote a contact as a moderator of the bubble, and false to downgrade
     * @description
     *  Promote or not a contact in a bubble
     *  The logged in user can't update himself. As a result, a 'moderator' can't be downgraded to 'user'.
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble updated with the modifications
     * @category async
     */
    promoteContactInBubble(contact: any, bubble: any, isModerator: any): Promise<unknown>;
    /**
     * @public
     * @method promoteContactToModerator
     * @since 1.65
     * @instance
     * @description
     *    Promote a contact to moderator in a bubble <br/>
     *    Return a promise.
     * @param {Contact} contact The contact to promote
     * @param {Bubble} bubble   The destination bubble
     * @return {Promise<Bubble, ErrorManager>} The bubble object or an error object depending on the result
     */
    promoteContactToModerator(contact: any, bubble: any): Promise<unknown>;
    /**
     * @public
     * @method demoteContactFromModerator
     * @since 1.65
     * @instance
     * @description
     *    Demote a contact to user in a bubble <br/>
     *    Return a promise.
     * @param {Contact} contact The contact to promote
     * @param {Bubble} bubble   The destination bubble
     * @return {Promise<Bubble, ErrorManager>} The bubble object or an error object depending on the result
     */
    demoteContactFromModerator(contact: any, bubble: any): Promise<unknown>;
    /**
     * @public
     * @method changeBubbleOwner
     * @instance
     * @param {Contact} contact         The contact to set a new bubble owner
     * @param {Bubble} bubble           The bubble
     * @description
     *  Set a moderator contact as owner of a bubble
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble updated with the modifications
     * @category async
     */
    changeBubbleOwner(bubble: any, contact: any): Promise<unknown>;
    /**
     * @public
     * @method removeContactFromBubble
     * @instance
     * @param {Contact} contact The contact to remove
     * @param {Bubble} bubble   The destination bubble
     * @description
     *    Remove a contact from a bubble
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble object or an error object depending on the result
     * @category async
     */
    removeContactFromBubble(contact: any, bubble: any): Promise<unknown>;
    /**
     * @private
     * @description
     *      Internal method
     */
    getBubbles(): Promise<unknown>;
    /**
     * @public
     * @method getAll
     * @instance
     * @return {Bubble[]} The list of existing bubbles
     * @description
     *  Return the list of existing bubbles
     */
    getAll(): Bubble[];
    /**
     * @public
     * @method getAllBubbles
     * @instance
     * @return {Bubble[]} The list of existing bubbles
     * @description
     *  Return the list of existing bubbles
     */
    getAllBubbles(): Bubble[];
    /**
     * @public
     * @method getAllOwnedBubbles
     * @instance
     * @description
     *    Get the list of bubbles created by the user <br/>
     * @return {Bubble[]} An array of bubbles restricted to the ones owned by the user
     */
    getAllOwnedBubbles(): Bubble[];
    private getBubbleFromCache;
    private addOrUpdateBubbleToCache;
    private removeBubbleFromCache;
    /**
     * @method getAvatarFromBubble
     * @public
     * @instance
     * @param {Bubble} bubble   The destination bubble
     * @async
     * @return {Promise<{}>}  return a promise with {Object} A Blob object with data about the avatar picture.
     * @description
     *  Get A Blob object with data about the avatar picture of the bubble.
     */
    getAvatarFromBubble(bubble: any): Promise<unknown>;
    /**
     * @private
     * @method refreshMemberAndOrganizerLists
     * @instance
     * @param {Bubble} bubble the bubble to refresh
     * @async
     * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null
     * @description
     *  Refresh members and organizers of the bubble.
     */
    refreshMemberAndOrganizerLists(bubble: any): any;
    /**
     * @public
     * @method getBubbleById
     * @instance
     * @param {string} id the id of the bubble
     * @param {boolean} [force=false] True to force a request to the server
     * @async
     * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null
     * @description
     *  Get a bubble by its ID in memory and if it is not found in server.
     */
    getBubbleById(id: any, force?: boolean): Promise<Bubble>;
    /**
     * @public
     * @method getBubbleByJid
     * @instance
     * @param {string} jid the JID of the bubble
     * @param {boolean} [force=false] True to force a request to the server
     * @async
     * @return {Promise<Bubble>}  return a promise with {Bubble} The bubble found or null
     * @description
     *  Get a bubble by its JID in memory and if it is not found in server.
     */
    getBubbleByJid(jid: any, force?: boolean): Promise<Bubble>;
    /**
     * @public
     * @method getAllPendingBubbles
     * @instance
     * @return {Bubble[]} An array of Bubbles not accepted or declined
     * @description
     *  Get the list of Bubbles that have a pending invitation not yet accepted of declined
     */
    getAllPendingBubbles(): Bubble[];
    /**
     * @public
     * @method getAllActiveBubbles
     * @since 1.30
     * @instance
     * @return {Bubble[]} An array of Bubbles that are "active" for the connected user
     * @description
     *  Get the list of Bubbles where the connected user can chat
     */
    getAllActiveBubbles(): Bubble[];
    /**
     * @public
     * @method getAllClosedBubbles
     * @since 1.30
     * @instance
     * @return {Bubble[]} An array of Bubbles that are closed for the connected user
     * @description
     *  Get the list of Bubbles where the connected user can only read messages
     */
    getAllClosedBubbles(): Bubble[];
    /**
     * @public
     * @method acceptInvitationToJoinBubble
     * @instance
     * @param {Bubble} bubble The Bubble to join
     * @description
     *  Accept an invitation to join a bubble
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble updated or an error object depending on the result
     * @category async
     */
    acceptInvitationToJoinBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method declineInvitationToJoinBubble
     * @instance
     * @param {Bubble} bubble The Bubble to decline
     * @description
     *  Decline an invitation to join a bubble
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble updated or an error object depending on the result
     * @category async
     */
    declineInvitationToJoinBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method setBubbleCustomData
     * @instance
     * @param {Bubble} bubble The Bubble
     * @param {Object} customData Bubble's custom data area. key/value format. Maximum and size are server dependent
     * @description
     *  Modify all custom data at once in a bubble
     *  To erase all custom data, put {} in customData
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The bubble updated with the custom data set or an error object depending on the result
     * @category async
     */
    setBubbleCustomData(bubble: any, customData: any): Promise<unknown>;
    /**
     * @private
     * @method setBubbleVisibilityStatus
     * @instance
     * @param {Bubble} bubble The Bubble
     * @param {string} status Bubble's public/private group visibility for search.  Either "private" (default) or "public"
     * @description
     *  Set the Bubble's visibility status
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The Bubble full data or an error object depending on the result
     * @category async
     */
    setBubbleVisibilityStatus(bubble: any, status: any): Promise<unknown>;
    /**
     * @public
     * @method setBubbleTopic
     * @instance
     * @param {Bubble} bubble The Bubble
     * @param {string} topic Bubble's topic
     * @description
     *  Set the Bubble's topic
     * @memberof Bubbles
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The Bubble full data or an error object depending on the result
     * @category async
     */
    setBubbleTopic(bubble: any, topic: any): Promise<unknown>;
    /**
     * @public
     * @method setBubbleName
     * @instance
     * @param {Bubble} bubble The Bubble
     * @param {string} topic Bubble's name
     * @description
     *  Set the Bubble's name
     * @async
     * @return {Promise<Bubble, ErrorManager>}
     * @fulfil {Bubble} - The Bubble full data or an error object depending on the result
     * @category async
     */
    setBubbleName(bubble: any, name: any): Promise<unknown>;
    randomString(length?: number): string;
    /**
     * @public
     * @method updateAvatarForBubble
     * @since 1.65
     * @instance
     * @description
     *    Update the bubble avatar (from given URL) <br/>
     *    The image will be automaticalle resized <br/>
     *    /!\ if URL isn't valid or given image isn't loadable, it'll fail <br/>
     *    Return a promise.
     * @param {string} urlAvatar  The avatarUrl
     * @param {Bubble} bubble  The bubble to update
     * @return {Bubble} A bubble object of null if not found
     */
    updateAvatarForBubble(urlAvatar: any, bubble: any): Promise<unknown>;
    /**
     * @private
     * @method setAvatarBubble
     * @param bubble
     * @param roomAvatarPath
     */
    setAvatarBubble(bubble: any, roomAvatarPath: any): Promise<unknown>;
    /**
     * @public
     * @method deleteAvatarFromBubble
     * @since 1.65
     * @instance
     * @description
     *    Delete the bubble avatar <br/>

     *    Return a promise.
     * @param {Bubble} bubble  The bubble to update
     * @return {Bubble} A bubble object of null if not found
     */
    deleteAvatarFromBubble(bubble: any): Promise<unknown>;
    /**
     * @private
     * @method deleteAvatarBubble
     * @param bubbleId
     */
    deleteAvatarBubble(bubbleId: any): Promise<unknown>;
    /**
     * @public
     * @method updateCustomDataForBubble
     * @since 1.64
     * @instance
     * @description
     *    Update the customData of the bubble  <br/>
     *    Return a promise.
     * @param {Object} customData
     *    The customData to put to the bubble <br />
     *    Example: { "key1" : 123, "key2" : "a string" }
     * @param {Bubble} bubble   The bubble to update
     * @return {Promise<Bubble>} The updated Bubble
     */
    updateCustomDataForBubble(customData: any, bubble: any): Promise<unknown>;
    /**
     * @public
     * @method deleteCustomDataForBubble
     * @since 1.65
     * @instance
     * @description
     *    Delete the customData of the bubble  <br/>
     *    Return a promise.
     * @param {Bubble} bubble   The bubble to update
     * @return {Promise<Bubble>} The updated Bubble
     */
    deleteCustomDataForBubble(bubble: any): Promise<unknown>;
    /**
     * @public
     * @method updateDescriptionForBubble
     * @since 1.65
     * @instance
     * @description
     *    Update the description of the bubble  <br/>
     *    Return a promise.
     * @param {string} strDescription   The description of the bubble (is is the topic on server side, and result event)
     * @param {Bubble} bubble   The bubble to update
     * @return {Bubble} A bubble object of null if not found
     */
    updateDescriptionForBubble(bubble: any, strDescription: any): Promise<unknown>;
    /**
     * @private
     * @method _onInvitationReceived
     * @instance
     * @param {Object} invitation contains informations about bubble and user's jid
     * @description
     *      Method called when receiving an invitation to join a bubble
     */
    _onInvitationReceived(invitation: any): void;
    /**
     * @private
     * @method _onAffiliationChanged
     * @instance
     * @param {Object} affiliation contains information about bubble and user's jid
     * @description
     *      Method called when affilitation to a bubble changed
     */
    _onAffiliationChanged(affiliation: any): Promise<void>;
    /**
     * @private
     * @method _onOwnAffiliationChanged
     * @instance
     * @param {Object} affiliation contains information about bubble and user's jid
     * @description
     *      Method called when the user affilitation to a bubble changed
     */
    _onOwnAffiliationChanged(affiliation: any): Promise<void>;
    /**
     * @private
     * @method _onCustomDataChanged
     * @instance
     * @param {Object} data contains information about bubble and new custom data received
     * @description
     *      Method called when custom data have changed for a bubble
     */
    _onCustomDataChanged(data: any): void;
    /**
     * @private
     * @method _onTopicChanged
     * @instance
     * @param {Object} data contains information about bubble new topic received
     * @description
     *      Method called when the topic has changed for a bubble
     */
    _onTopicChanged(data: any): void;
    /**
     * @private
     * @method _onPrivilegeBubbleChanged
     * @instance
     * @param {Object} bubbleInfo modified bubble info
     * @description
     *     Method called when the owner of a bubble changed.
     */
    _onPrivilegeBubbleChanged(bubbleInfo: any): Promise<void>;
    /**
     * @private
     * @method _onNameChanged
     * @instance
     * @param {Object} data contains information about bubble new name received
     * @description
     *      Method called when the name has changed for a bubble
     */
    _onNameChanged(data: any): void;
    /**
     * @private
     * @method _onbubblepresencechanged
     * @instance
     * @param {Object} bubbleInfo contains information about bubble
     * @description
     *      Method called when the name has changed for a bubble
     */
    _onbubblepresencechanged(bubbleInfo: any): Promise<void>;
    /**
     * @private
     * @method getInfoForPublicUrlFromOpenInvite
     * @since 1.72
     * @instance
     * @description
     *     get infos for the PublicUrl
     * @return {Promise<any>}
     */
    getInfoForPublicUrlFromOpenInvite(openInvite: any): Promise<any>;
    /**
     *
     * @public
     * @method getAllPublicUrlOfBubbles
     * @since 1.72
     * @instance
     * @description
     *     get all the PublicUrl belongs to the connected user
     * @return {Promise<any>}
     */
    getAllPublicUrlOfBubbles(): Promise<any>;
    /**
     *
     * @public
     * @method getAllPublicUrlOfBubblesOfAUser
     * @since 1.72
     * @instance
     * @param  {Contact} contact user used to get all his Public Url. If not setted the connected user is used.
     * @description
     *     get all the PublicUrl belongs to a user
     * @return {Promise<any>}
     */
    getAllPublicUrlOfBubblesOfAUser(contact?: Contact): Promise<any>;
    /**
     *
     * @public
     * @method getAllPublicUrlOfABubble
     * @since 1.72
     * @instance
     * @param {Bubble} bubble bubble from where get the public link.
     * @description
     *     get all the PublicUrl of a bubble belongs to the connected user
     * @return {Promise<any>}
     */
    getAllPublicUrlOfABubble(bubble: any): Promise<any>;
    /**
     *
     * @public
     * @method getAllPublicUrlOfABubbleOfAUser
     * @since 1.72
     * @instance
     * @param {Contact} contact user used to get all his Public Url. If not setted the connected user is used.
     * @param {Bubble} bubble bubble from where get the public link.
     * @description
     *     get all the PublicUrl of a bubble belong's to a user
     * @return {Promise<any>}
     */
    getAllPublicUrlOfABubbleOfAUser(contact: Contact, bubble: Bubble): Promise<any>;
    /**
     * @public
     * @method createPublicUrl
     * @since 1.72
     * @instance
     * @description
     *    Create / Get the public URL used to access the specified bubble. So a Guest or a Rainbow user can access to it just using a URL <br/>
     *    Return a promise.
     * @param {Bubble} bubbleId   Id of the bubble
     * @return {Promise<string>} The public url
     */
    createPublicUrl(bubbleId: string): Promise<any>;
    /**
     * @public
     * @method generateNewPublicUrl
     * @since 1.72
     * @instance
     * @description
     *    Generate a new public URL to access the specified bubble (So a Guest or a Rainbow user can access to it just using a URL) <br/>
     *    Return a promise.
     *
     *    !!! The previous URL is no more functional !!!
     * @param {Bubble} bubbleId   Id of the bubble
     * @return {Promise<string>} The public url
     */
    generateNewPublicUrl(bubbleId: string): Promise<any>;
    /**
     * @public
     * @method removePublicUrl
     * @since 1.72
     * @instance
     * @description
     *    'Remove' the public URL used to access the specified bubble. So it's no more possible to access to this buble using this URL <br/>
     *    Return a promise.
     * @param {Bubble} bubbleId   Id of the bubble
     * @return {Promise<any>} An object of the result
     */
    removePublicUrl(bubbleId: string): Promise<any>;
    /**
     * @private
     * @method GetPublicURLFromResponseContent
     * @since 1.72
     * @instance
     * @description
     *    retrieve the public url from public url object.
     * @param {Object} content   Id of the bubble
     * @return {string} An url
     */
    getPublicURLFromResponseContent(content: any): string;
    /**
     * @private
     * @method registerGuestForAPublicURL
     * @since 1.75
     * @instance
     * @description
     *    register a guest user with a mail and a password and join a bubble with a public url.
     *    For this use case, first generate a public link using createPublicUrl(bubbleId) API for the requested bubble.
     *    If the provided openInviteId is valid, the user account is created in guest mode (guestMode=true)
     *    and automatically joins the room to which the public link is bound.
     * @param {Object} content   Id of the bubble
     * @return {string} An url
     */
    registerGuestForAPublicURL(openInviteId: string, loginEmail: string, password: string): Promise<unknown>;
    joinConference(bubble: any): Promise<unknown>;
    getBubbleByConferenceIdFromCache(conferenceId: string): Bubble;
    getBubbleIdByConferenceIdFromCache(conferenceId: string): string;
    conferenceAllowed(): boolean;
    conferenceGetByIdFromCache(conferenceId: string): ConferenceSession;
    conferenceGetListFromCache(): List<ConferenceSession>;
    /**
     * @Method retrieveConferences
     * @public
     * @param {string} mediaType [optional] mediaType of conference(s) to retrive.
     * @param {boolean} scheduled [optional] whether it is a scheduled conference or not
     * @param {boolean} provisioning [optional] whether it is a conference that is in provisioning state or not
     * @returns {ng.IPromise<any>} a promise that resolves when conference are retrieved. Note: If no parameter is specified, then all mediaTypes are retrieved
     * @memberof ConferenceService
     */
    retrieveConferences(mediaType?: string, scheduled?: boolean, provisioning?: boolean): Promise<any>;
    /**
     * @Method updateOrCreateWebConferenceEndpoint
     * @public
     * @param {any} conferenceData [required] conference data for the update / creation
     * @returns {any} the updated conferenceEndpoint or null on error
     * @memberof BubblesService
     */
    updateOrCreateWebConferenceEndpoint(conferenceData: any): any;
    updateWebConferenceInfos(endpoints: any[]): void;
    /**
     * @Method getWebRtcConfEndpointId
     * @public
     * @returns {string} the user unique webrtc conference enpoint id
     * @memberof BubblesService
     */
    getWebRtcConfEndpointId(): string;
    /**
     * @Method getWebRtcSharingOnlyConfEndpointId
     * @public
     * @returns {string} the user unique webrtcSharingOnly  conference enpoint id
     * @memberof BubblesService
     */
    getWebRtcSharingOnlyConfEndpointId(): string;
    /**
     * @public
     * @method conferenceStart
     * @since 1.73
     * @instance
     * @description
     *     To start a conference.
     *     Only a moderator can start a conference. It also need to be a premium account.
     * @param {Bubble} bubble   The bubble where the conference should start
     * @param {string} conferenceId The id of the conference that should start. Optional, if not provided then the webrtc conference is used.
     * @return {Promise<any>} The result of the starting.
     */
    conferenceStart(bubble: any, conferenceId: string): Promise<any>;
    /**
     * @public
     * @method conferenceStop
     * @since 1.73
     * @instance
     * @description
     *     To stop a conference.
     *     Only a moderator can stop a conference. It also need to be a premium account.
     * @param {string} conferenceId The id of the conference that should stop
     * @return {Promise<any>} return undefined.
     */
    conferenceStop(conferenceId: string): Promise<unknown>;
    conferenceJoin(conferenceId: string, asModerator: boolean, muted: boolean, phoneNumber: string, country: string): Promise<unknown>;
    conferenceMuteOrUnmute(conferenceId: string, mute: boolean): void;
    conferenceMuteOrUnmutParticipant(conferenceId: string, participantId: string, mute: boolean): void;
    conferenceDropParticipant(conferenceId: string, participantId: string): Promise<unknown>;
    personalConferenceAllowed(): boolean;
    personalConferenceGetId(): string;
    personalConferenceGetBubbleFromCache(): Promise<Bubble>;
    personalConferenceGetBubbleIdFromCache(): string;
    personalConferenceGetPhoneNumbers(): Promise<any>;
    personalConferenceGetPassCodes(): Promise<ConferencePassCodes>;
    personalConferenceResetPassCodes(): Promise<any>;
    personalConferenceGetPublicUrl(): Promise<any>;
    personalConferenceGenerateNewPublicUrl(): Promise<any>;
    personalConferenceStart(): Promise<any>;
    personalConferenceStop(): Promise<any>;
    personalConferenceJoin(asModerator: boolean, muted: boolean, phoneNumber: string, country: string): Promise<any>;
    personalConferenceMuteOrUnmute(mute: boolean): Promise<unknown>;
    personalConferenceLockOrUnlock(toLock: boolean): Promise<unknown>;
    personalConferenceMuteOrUnmutParticipant(participantId: string, mute: boolean): Promise<any>;
    personalConferenceDropParticipant(participantId: string): Promise<any>;
    conferenceEndedForBubble(bubbleJid: string): Promise<void>;
    askBubbleForConferenceDetails(bubbleJid: string): void;
    personalConferenceRename(name: string): Promise<unknown>;
    askConferenceSnapshot(conferenceId: string, type: MEDIATYPE): Promise<unknown>;
    conferenceModeratorAction(conferenceId: string, action: string): Promise<unknown>;
    conferenceModeratorActionOnParticipant(conferenceId: string, participantId: string, action: string): Promise<unknown>;
    removeConferenceFromCache(conferenceId: string, deleteLinkWithBubble: boolean): void;
    addConferenceToCache(conference: ConferenceSession): void;
}
export { Bubbles as BubblesService };
