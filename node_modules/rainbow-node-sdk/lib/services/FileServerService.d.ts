/// <reference types="node" />
export {};
import { Logger } from "../common/Logger";
import { EventEmitter } from "events";
import { Core } from "../Core";
declare class FileServer {
    private _eventEmitter;
    private _logger;
    private _capabilities;
    private transferPromiseQueue;
    private _fileStorageService;
    ONE_KILOBYTE: any;
    private _xmpp;
    private _rest;
    private _options;
    private _s2s;
    private _useXMPP;
    private _useS2S;
    ONE_MEGABYTE: any;
    ready: boolean;
    private readonly _startConfig;
    get startConfig(): {
        start_up: boolean;
        optional: boolean;
    };
    constructor(_eventEmitter: EventEmitter, _logger: Logger, _startConfig: any);
    get capabilities(): Promise<any>;
    start(_options: any, _core: Core): Promise<unknown>;
    stop(): Promise<unknown>;
    init(): Promise<unknown>;
    /**
     * Method retrieve data from server using range request mecanism (RFC7233)
     *
     * @private
     * @param {string} url [required] server url for request
     * @param {number} minRange [requied] minimum value of range
     * @param {number} maxRange [required] maximum value of range
     * @param {number} index [required] index of the part. Used to re-assemble the data
     * @returns {Object} structure containing the response data from server and the index
     *
     */
    getPartialDataFromServer(url: any, minRange: any, maxRange: any, index: any): Promise<unknown>;
    /**
     * Method creates buffer from a file retrieved from server using optimization (range request) whenever necessary
     *
     * @param {string} url [required] server url for request
     * @param {string} mime [required] Mime type of the blob to be created
     * @param {number} fileSize [optional] size of file to be retrieved. Default: 0
     * @param {string} fileName [optional] name of file to be downloaded
     * @returns {Buffer} Buffer created from data received from server
     *
     */
    getBufferFromUrlWithOptimization(url: any, mime: any, fileSize: any, fileName: any, uploadedDate: any): Promise<unknown>;
    /**
     * Method creates buffer from a file retrieved from server using optimization (range request) whenever necessary
     *
     * @param destFile
     * @param {string} url [required] server url for request
     * @param {string} mime [required] Mime type of the blob to be created
     * @param {number} fileSize [optional] size of file to be retrieved. Default: 0
     * @param {string} fileName [optional] name of file to be downloaded
     * @param {string} uploadedDate [optional] date of the upload
     * @returns {Buffer} Buffer created from data received from server
     *
     */
    getFileFromUrlWithOptimization(destFile: any, url: any, mime: any, fileSize: any, fileName: any, uploadedDate: any): Promise<unknown>;
    /***
     * @private
     * @param fileDescriptor
     * @param large
     */
    getBlobThumbnailFromFileDescriptor(fileDescriptor: any, large?: boolean): Promise<void>;
    /**
     * Method sends data file to server
     *
     * @private
     * @param {string} fileId [required] file descriptor ID of file to be sent
     * @param {File} file [required] file to be sent
     * @param {string} mime [required] mime type of file
     * @returns {Promise<FileDescriptor>} file descriptor data received as response from server or http error response
     *
     */
    _uploadAFile(fileId: any, filePath: any, mime: any): Promise<unknown>;
    /**
     * Method sends data to server using range request mecanism (RFC7233)
     *
     * @private
     * @param {string} fileId [required] file descriptor ID of file to be sent
     * @param {Blob} file [required] file to be sent
     * @param {number} initialSize [required] initial size of whole file to be sent before partition
     * @param {number} minRange [requied] minimum value of range
     * @param {number} maxRange [required] maximum value of range
     * @param {number} index [required] index of the part. Used to indicate the part number to the server
     * @returns {Promise<{}>} file descriptor data received as response from server or http error response
     *
     */
    _sendPartialDataToServer(fileId: any, file: any, index: any): Promise<unknown>;
    /**
     * Upload File ByChunk progressCallback callback is displayed as part of the Requester class.
     * @callback uploadAFileByChunk~progressCallback
     * @param {FileDescriptor} fileDescriptor
     */
    /**
     * Method sends data to server using range request mecanism (RFC7233)
     *
     * @private
     * @param {FileDescriptor} fileDescriptor [required] file descriptor Object of file to be sent
     * @param {File} file [required] filePath of the file to be sent
//     * @param {uploadAFileByChunk~progressCallback} progressCallback [required] initial size of whole file to be sent before partition
     * @returns {Promise<{FileDescriptor}>} file descriptor data received as response from server or http error response
     *
     */
    uploadAFileByChunk(fileDescriptor: any, filePath: any): Promise<any>;
    isTransferInProgress(): any;
    cancelAllTransfers(): void;
    /**
     * Method creates blob from a file retrieved from server using optimization (range request) whenever necessary
     *
     * @param {string} url [required] server url for request
     * @param {string} mime [required] Mime type of the blob to be created
     * @param {number} fileSize [optional] size of file to be retrieved. Default: 0
     * @param {string} fileName [optional] name of file to be downloaded
     * @returns {Promise<Blob>} Blob created from data received from server
     *
     * !!!!!! OBSOLETE
     */
    getBlobFromUrlWithOptimization(url: any, mime: any, fileSize: any, fileName: any, uploadedDate: any): Promise<unknown>;
    /**
     * Method creates blob from a file retrieved from server
     *
     * @private
     * @param {string} url [required] server url for request
     * @param {string} mime [required] Mime type of the blob to be created
     * @param {number} fileSize [required] size of file to be retrieved
     * @param {string} fileName [required] name of file to be downloaded
     * @returns {ng.IPromise<Blob>} Blob created from data received from server
     *
     */
    getBlobFromUrl(url: any, mime: any, fileSize: any, fileName: any): Promise<unknown>;
    /**
    * Method retrieves user quota (capabilities) for user
    *
    * @returns {Capabilities} user quota for user
    *
    */
    getServerCapabilities(): Promise<unknown>;
}
export { FileServer as FileServerService };
