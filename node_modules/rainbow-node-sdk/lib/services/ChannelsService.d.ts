/// <reference types="node" />
export {};
import { Appreciation, Channel } from "../common/models/Channel";
import { EventEmitter } from "events";
import { Logger } from "../common/Logger";
import { Core } from "../Core";
declare class Channels {
    private _xmpp;
    private _rest;
    private _options;
    private _s2s;
    private _useXMPP;
    private _useS2S;
    private _channels;
    private _channelsList;
    private _eventEmitter;
    private _logger;
    MAX_ITEMS: any;
    MAX_PAYLOAD_SIZE: any;
    PUBLIC_VISIBILITY: any;
    PRIVATE_VISIBILITY: any;
    CLOSED_VISIBILITY: any;
    private channelEventHandler;
    private channelHandlerToken;
    invitationCounter: number;
    ready: boolean;
    private readonly _startConfig;
    get startConfig(): {
        start_up: boolean;
        optional: boolean;
    };
    LIST_EVENT_TYPE: {
        ADD: {
            code: number;
            label: string;
        };
        UPDATE: {
            code: number;
            label: string;
        };
        REMOVE: {
            code: number;
            label: string;
        };
        DELETE: {
            code: number;
            label: string;
        };
        SUBSCRIBE: {
            code: number;
            label: string;
        };
        UNSUBSCRIBE: {
            code: number;
            label: string;
        };
        CREATE: {
            code: number;
            label: string;
        };
    };
    USER_ROLE: {
        NONE: string;
        OWNER: string;
        PUBLISHER: string;
        MEMBER: string;
    };
    constructor(_eventEmitter: EventEmitter, _logger: Logger, _startConfig: any);
    start(_options: any, _core: Core): Promise<unknown>;
    stop(): Promise<unknown>;
    attachHandlers(): void;
    /**
     * @public
     * @method createChannel
     * @instance
     * @async
     * @param {string} name  The name of the channel to create (max-length=255)
     * @param {string} [channelTopic]  The description of the channel to create (max-length=255)
     * @return {Promise<Channel>} New Channel
     * @description
     *  Create a new public channel with a visibility limited to my company
     */
    createChannel(name: any, channelTopic: any): Promise<Channel>;
    /**
     * @public
     * @method createPublicChannel
     * @instance
     * @async
     * @param {string} name  The name of the channel to create (max-length=255)
     * @param {string} [channelTopic]  The description of the channel to create (max-length=255)
     * @param {String} [category=""] The category of the channel
     * @return {Promise<Channel>} New Channel
     * @description
     *  Create a new public channel with a visibility limited to my company
     */
    createPublicChannel(name: any, channelTopic: any, category: any): Promise<Channel>;
    /**
     * @public
     * @method createClosedChannel (ex: createPrivateChannel)
     * @instance
     * @async
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the createClosedChannel method instead,
     * @param {string} name  The name of the channel to create (max-length=255)
     * @param {string} [description]  The description of the channel to create (max-length=255)
     * @return {Promise<Channel>} New Channel
     * @description
     *  Create a new private channel
     */
    createPrivateChannel(name: any, description: any): Promise<Channel>;
    /**
     * @public
     * @method createClosedChannel (ex: createPrivateChannel)
     * @instance
     * @async
     * @param {string} name  The name of the channel to create (max-length=255)
     * @param {string} [description]  The description of the channel to create (max-length=255)
     * @param {String} [category=""] The category of the channel
     * @return {Promise<Channel>} New Channel
     * @description
     *  Create a new closed channel
     */
    createClosedChannel(name: any, description: any, category: any): Promise<Channel>;
    /**
     * @public
     * @method deleteChannel
     * @instance
     * @async
     * @param {Channel} channel  The channel to delete
     * @return {Promise<CHannel>} Promise object represents The channel deleted
     * @description
     *  Delete a owned channel
     */
    deleteChannel(channel: any): Promise<Channel>;
    /**
     * @public
     * @method findChannelsByName
     * @instance
     * @async
     * @param {String} name Search this provided substring in the channel name (case insensitive).
     * @return {Promise<Channel[]>} Channels found
     * @description
     *  Find channels by name. Only channels with visibility equals to 'company' can be found. First 100 results are returned.
     */
    findChannelsByName(name: string): Promise<[Channel]>;
    /**
     * @public
     * @method findChannelsByTopic
     * @instance
     * @async
     * @param {String} topic Search this provided substring in the channel topic (case insensitive).
     * @return {Promise<Channel[]>} Channels found
     * @description
     *  Find channels by topic. Only channels with visibility equals to 'company' can be found. First 100 results are returned.
     */
    findChannelsByTopic(topic: string): Promise<[Channel]>;
    /**
     * @private
     * @method findChannels
     */
    private _findChannels;
    /**
     * @public
     * @method getChannelById
     * @instance
     * @async
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the fetchChannel method instead,
     * @param {String} id The id of the channel)
     * @param {boolean} [force=false] True to force a request to the server
     * @return {Promise<Channel>} The channel found
     * @description
     * Find a channel by its id (locally if exists or by sending a request to Rainbow)
     */
    getChannelById(id: any, force?: any): Promise<Channel>;
    /**
     * @public
     * @method fetchChannel
     * @instance
     * @async
     * @param {String} id The id of the channel)
     * @param {boolean} [force=false] True to force a request to the server
     * @return {Promise<Channel>} The channel found
     * @description
     * Find a channel by its id (locally if exists or by sending a request to Rainbow)
     */
    fetchChannel(id: any, force?: any): Promise<Channel>;
    /**
     * @public
     * @method fetchChannelsByFilter
     * @since 1.55
     * @instance
     * @description
     *    Find channels using a filter (on name, topic)<br/>
     *    Result may be filtered with result limit, offet and sortField or SortOrder
     *    Return a promise.
     * @param {Object} filter The filter with at least [filter.name] or [filter.topic] defined
     *      {String} [filter.name] search by channel names (case insensitive substring).
     *      {String} [filter.topic] search by channel topics (case insensitive substring).
     *      {Number} [filter.limit=100] allow to specify the number of channels to retrieve.
     *      {Number} [filter.offset] allow to specify the position of first channel to retrieve (first channel if not specified). Warning: if offset > total, no results are returned.
     *      {String} [filter.sortField="name"] sort channel list based on the given field.
     *      {Number} [filter.sortOrder="1"] specify order ascending/descending. 1 for ascending, -1 for descending.
     * @return {Promise<Channel[]>} Result of the find with
     *      {Array}   found channels informations with an array of { id, name, topic, creatorId, visibility, users_count }
     */
    fetchChannelsByFilter(filter: any): Promise<[Channel]>;
    /**
     * @public
     * @method getChannels
     * @since 1.38
     * @instance
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the fetchMyChannels method instead,
     * @description
     *    Get the channels you own, are subscribed to, are publisher<br/>
     *    Return a promise.
     * @return {{Promise<Channel[]>} } Return Promise with a list of channels or an empty array if no channel has been found
     */
    getChannels(): Promise<[Channel]>;
    /**
     * @public
     * @method fetchMyChannels
     * @since 1.38
     * @instance
     * @description
     *    Get the channels you own, are subscribed to, are publisher<br/>
     *    Return a promise.
     * @return {Promise<Channel[]>} Return Promise with a list of channels or an empty array if no channel has been found
     */
    fetchMyChannels(): Promise<[Channel]>;
    /**
     * @public
     * @method getAllChannels
     * @instance
     * @return {Channel[]} An array of channels (owned, invited, subscribed)
     * @description
     *  Return the list of channels (owned, invited, subscribed)
     */
    getAllChannels(): [Channel];
    /**
     * @public
     * @method getAllOwnedChannel
     * @instance
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the getAllOwnedChannels method instead,
     * @return {Channel[]} An array of channels (owned only)
     * @description
     *  Return the list of owned channels only
     */
    getAllOwnedChannel(): [Channel];
    /**
     * @public
     * @method getAllOwnedChannels
     * @instance
     * @return {Channel[]} An array of channels (owned only)
     * @description
     *  Return the list of owned channels only
     */
    getAllOwnedChannels(): [Channel];
    /**
     * @public
     * @method getAllSubscribedChannel
     * @instance
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the getAllSubscribedChannels method instead,
     * @return {Channel[]} An array of channels (subscribed only)
     * @description
     *  Return the list of subscribed channels only
     */
    getAllSubscribedChannel(): [Channel];
    /**
     * @public
     * @method getAllSubscribedChannels
     * @instance
     * @return {Channel[]} An array of channels (subscribed only)
     * @description
     *  Return the list of subscribed channels only
     */
    getAllSubscribedChannels(): [Channel];
    /**
     * @public
     * @method getAllPendingChannels
     * @instance
     * @return {Channel[]} An array of channels (invited only)
     * @description
     *  Return the list of invited channels only
     */
    getAllPendingChannels(): [Channel];
    /**
     * @public
     * @method publishMessageToChannel
     * @instance
     * @async
     * @param {Channel} channel The channel where to publish the message
     * @param {String} message Message content
     * @param {String} [title = "", limit=256] Message title
     * @param {String} [url = ""] An URL
     * @param {id[]} [imagesIds = null] An Array of ids of the files stored in Rainbow
     * @param {String} [type="basic"] An optional message content type (could be basic, markdown, html or data)
     * @return {Promise<ErrorManager.getErrorManager().OK>} OK if successfull
     * @description
     *  Publish to a channel
     */
    publishMessageToChannel(channel: any, message: any, title: any, url: any, imagesIds: any, type: any): Promise<{}>;
    /**
     * @public
     * @method createItem
     * @instance
     * @async
     * @param {Channel} channel The channel where to publish the message
     * @param {String} message Message content
     * @param {String} [title = "", limit=256] Message title
     * @param {String} [url = ""] An URL
     * @param {id[]} [imagesIds = null] An Array of ids of the files stored in Rainbow
     * @param {String} [type="basic"] An optional message content type (could be basic, markdown, html or data)
     * @return {Promise<ErrorManager.getErrorManager().OK>} OK if successfull
     * @description
     *  Publish to a channel
     */
    createItem(channel: any, message: any, title: any, url: any, imagesIds: any, type: any): Promise<{}>;
    /**
     * @public
     * @method subscribeToChannel
     * @instance
     * @async
     * @param {Channel} channel The channel to subscribe
     * @return {Promise<Channel>} The channel updated with the new subscription
     * @description
     *  Subscribe to a public channel
     */
    subscribeToChannel(channel: Channel): Promise<Channel>;
    /**
     * @public
     * @method
     * @since 1.47
     * @instance
     * @description
     *    Subscribe to a channel using its id<br/>
     *    Return a promise.
     * @param {String} id The id of the channel
     * @return {Object} Nothing or an error object depending on the result
     */
    subscribeToChannelById(id: any): Promise<unknown>;
    /**
     * @public
     * @method unsubscribeFromChannel
     * @instance
     * @async
     * @param {Channel} channel The channel to unsubscribe
     * @return {Promise<String>} The status of the unsubscribe.
     * @description
     *  Unsubscribe from a public channel
     */
    unsubscribeFromChannel(channel: Channel): Promise<String>;
    /**
     * @public
     * @method updateChannelTopic
     * @instance
     * @async
     * @param {Channel} channel The channel to update
     * @param {string} description  The description of the channel to update (max-length=255)
     * @return {Promise<Channel>} Updated channel
     * @description
     *  TODO
     */
    updateChannelTopic(channel: any, description: any): Promise<Channel>;
    /**
     * @public
     * @method updateChannelDescription
     * @instance
     * @async
     * @param {Channel} channel The channel to update
     * @param {string} description  The description of the channel to update (max-length=255)
     * @return {Promise<Channel>} Updated channel
     * @description
     *  TODO
     */
    updateChannelDescription(channel: any, description: any): Promise<Channel>;
    /**
     * @public
     * @method
     * @since 1.46
     * @instance
     * @description
     *    Update a channel name<br/>
     *    Return a promise.
     * @param {Channel} channel The channel to update
     * @param {String} channelName The name of the channel
     * @return {Channel} Return the channel updated or an error
     */
    updateChannelName(channel: any, channelName: any): Promise<unknown>;
    /**
     * @public
     * @method
     * @since 1.38
     * @instance
     * @description
     *    Update a channel<br/>
     *      May be updated: name, topic, visibility, max_items and max_payload<br/>
     *      Please put null to not update a property.<br/>
     *    Return a promise.
     * @param {String} id The id of the channel
     * @param {String} [channelTopic=""] The topic of the channel
     * @param {String} [visibility=public] public/company/closed group visibility for search
     * @param {Number} [max_items=30] max # of items to persist in the channel
     * @param {Number} [max_payload_size=60000] max # of items to persist in the channel
     * @param {String} [channelName=""] The name of the channel
     * @param {String} [category=""] The category of the channel
     * @return {Promise<Channel>} Return the channel created or an error
     */
    updateChannel(id: any, channelTopic: any, visibility: any, max_items: any, max_payload_size: any, channelName: any, category: any): Promise<unknown>;
    /**
     * @public
     * @method updateChannelVisibility
     * @since 1.55
     * @instance
     * @description
     *    Update a channel visibility<br/>
     *    Return a promise.
     * @param {String} channel The channel to update
     * @param {String} visibility  The new channel visibility (closed or company)
     * @return {Promise<Channel>} Return the channel updated or an error
     */
    updateChannelVisibility(channel: any, visibility: any): Promise<unknown>;
    /**
     * @public
     * @method updateChannelVisibilityToPublic
     * @since 1.55
     * @instance
     * @description
     *    Set the channel visibility to company (visible for users in that company)<br/>
     *    Return a promise.
     * @param {String} channel The channel to update
     * @return {Channel} Return the channel updated or an error
     */
    updateChannelVisibilityToPublic(channel: any): Promise<unknown>;
    /**
     * @public
     * @method updateChannelVisibilityToClosed
     * @since 1.55
     * @instance
     * @description
     *    Set the channel visibility to closed (not visible by users)<br/>
     *    Return a promise.
     * @param {String} channel The channel to update
     * @return {Channel} Return the channel updated or an error
     */
    updateChannelVisibilityToClosed(channel: any): Promise<unknown>;
    /**
     * @public
     * @method
     * @since 1.43
     * @instance
     * @description
     *    Update a channel avatar<br/>
     *    Return a promise.
     * @param {Channel} channel The Channel to update
     * @param {string} urlAvatar  The avatar Url.  It must be resized to 512 pixels before calling this API.
     * @return {Channel} Return the channel updated or an error
     */
    updateChannelAvatar(channel: any, urlAvatar: any): Promise<unknown>;
    /**
     * @public
     * @method
     * @since 1.43
     * @instance
     * @description
     *    Delete a channel avatar<br/>
     *    Return a promise.
     * @param {Channel} channel The channel to update
     * @return {Channel} Return the channel updated or an error
     */
    deleteChannelAvatar(channel: any): Promise<unknown>;
    /**
     * @public
     * @method fetchChannelUsers
     * @instance
     * @async
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the fetchChannelUsers method instead,
     * @param {Channel} channel The channel
     * @param {Object} [options] A filter parameter
     * @param {Number} [options.page = 0] Display a specific page of results
     * @param {Number} [options.limit=100] Number of results per page (max 1000)
     * @param {Boolean} [options.onlyPublishers=false] Filter to publishers only
     * @param {Boolean} [options.onlyOwners=false] Filter to owners only
     * @return {Promise<Users[]>} An array of users who belong to this channel
     * @description
     *  Get a pagined list of users who belongs to a channel
     */
    getUsersFromChannel(channel: any, options: any): Promise<{}[]>;
    /**
     * @public
     * @method fetchChannelUsers
     * @instance
     * @async
     * @param {Channel} channel The channel
     * @param {Object} [options] A filter parameter
     * @param {Number} [options.page = 0] Display a specific page of results
     * @param {Number} [options.limit=100] Number of results per page (max 1000)
     * @param {Boolean} [options.onlyPublishers=false] Filter to publishers only
     * @param {Boolean} [options.onlyOwners=false] Filter to owners only
     * @return {Promise<Users[]>} An array of users who belong to this channel
     * @description
     *  Get a pagined list of users who belongs to a channel
     */
    fetchChannelUsers(channel: any, options: any): Promise<Array<{}>>;
    /**
     * @public
     * @method removeAllUsersFromChannel
     * @instance
     * @async
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the deleteAllUsersFromChannel method instead,
     * @param {String} channel The channel
     * @return {Promise<Channel>} The channel updated
     * @description
     *  Remove all users from a channel
     */
    removeAllUsersFromChannel(channel: any): Promise<Channel>;
    /**
     * @public
     * @method deleteAllUsersFromChannel
     * @instance
     * @async
     * @param {String} channel The channel
     * @return {Promise<Channel>} The channel updated
     * @description
     *  Remove all users from a channel
     */
    deleteAllUsersFromChannel(channel: any): Promise<Channel>;
    /**
     * @public
     * @method updateChannelUsers
     * @instance
     * @async
     * @param {String} channelId The Id of the channel
     * @param {ChannelUser[]} users The users of the channel
     * @return {Promise<Channel>} Update Channel Users status
     * @description
     *  TODO
     */
    updateChannelUsers(channel: any, users: any): Promise<Channel>;
    /**
     * @public
     * @method addOwnersToChannel
     * @instance
     * @async
     * @param {Channel} channel The channel
     * @param owners
     * @return {Promise<Channel>} The updated channel
     * @description
     *  Add a list of owners to the channel
     */
    addOwnersToChannel(channel: Channel, owners: any): Promise<Channel>;
    /**
     * @public
     * @method addPublishersToChannel
     * @instance
     * @async
     * @param {Channel} channel The channel
     * @param {User[]} users An array of users to add
     * @return {Promise<Channel>} The updated channel
     * @description
     *  Add a list of publishers to the channel
     */
    addPublishersToChannel(channel: Channel, publishers: any): Promise<Channel>;
    /**
     * @public
     * @method addMembersToChannel
     * @instance
     * @async
     * @param {Channel} channel The channel
     * @param {User[]} users An array of users to add
     * @return {Promise<Channel>} The updated channel
     * @description
     *  Add a list of members to the channel
     */
    addMembersToChannel(channel: any, members: any): Promise<Channel>;
    /**
     * @public
     * @method removeUsersFromChannel1
     * @instance
     * @async
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the deleteUsersFromChannel method instead,
     * @param {Channel} channel The channel
     * @param {User[]} users An array of users to remove
     * @return {Promise<Channel>} The updated channel
     * @description
     *  Remove a list of users from a channel
     */
    removeUsersFromChannel1(channel: any, users: any): Promise<Channel>;
    /**
     * @public
     * @method deleteUsersFromChannel
     * @instance
     * @async
     * @param {Channel} channel The channel
     * @param {User[]} users An array of users to remove
     * @return {Promise<Channel>} The updated channel
     * @description
     *  Remove a list of users from a channel
     */
    deleteUsersFromChannel(channel: Channel, users: any): Promise<Channel>;
    /**
     * @public
     * @method getMessagesFromChannel
     * @instance
     * @async
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the fetchChannelItems method instead,
     * @param {Channel} channel The channel
     * @return {Promise<Object[]>} The list of messages received
     * @description
     *  Retrieve the last messages from a channel
     */
    getMessagesFromChannel(channel: any): Promise<any[]>;
    /**
     * @public
     * @method fetchChannelItems
     * @instance
     * @async
     * @param {Channel} channel The channel
     * @return {Promise<Object[]>} The list of messages received
     * @description
     *  Retrieve the last messages from a channel
     */
    fetchChannelItems(channel: Channel): Promise<Array<any>>;
    /**
     * @public
     * @method deleteMessageFromChannel
     * @instance
     * @async
     * @deprecated [#1] since version 1.55 [#2].
     * [#3] Will be deleted in future version
     * [#4] In case you need similar behavior use the deleteItemFromChannel method instead,
     * @param  {String} channelId The Id of the channel
     * @param  {String} messageId The Id of the message
     * @return {Promise<Channel>} The channel updated
     * @description
     *  Delete a message from a channel
     */
    deleteMessageFromChannel(channelId: any, messageId: any): Promise<Channel>;
    /**
     * @public
     * @method deleteItemFromChannel
     * @instance
     * @async
     * @param  {String} channelId The Id of the channel
     * @param  {String} itemId The Id of the item
     * @return {Promise<Channel>} The channel updated
     * @description
     *  Delete a message from a channel
     */
    deleteItemFromChannel(channelId: any, itemId: any): Promise<Channel>;
    _onChannelMessageReceived(message: any): void;
    _onChannelMyAppreciationReceived(my_appreciation: any): void;
    /**
     * @private
     * @param channelId
     * @description
     *      GET A CHANNEL
     */
    getChannel(channelId: string): Promise<Channel>;
    /**
     * @public
     * @method likeItem
     * @instance
     * @async
     * @param  {Channel} channel The channel where the item must be liked.
     * @param  {String} itemId The Id of the item
     * @param {Appreciation} appreciation Appreciation value - must be one of the value specified in Appreciation object.
     * @return {Promise<any>}
     * @description
     *  To like an Channel Item with the specified appreciation
     */
    likeItem(channel: any, itemId: any, appreciation: Appreciation): Promise<any>;
    /**
     * @public
     * @method getDetailedAppreciations
     * @instance
     * @async
     * @param  {Channel} channel The channel where the item appreciations must be retrieved.
     * @param  {String} itemId The Id of the item
     * @return {Promise<any>}
     * @description
     *  To know in details apprecations given on a channel item (by userId the apprecation given)
     */
    getDetailedAppreciations(channel: any, itemId: any): Promise<any>;
    /**
     * @private
     * @param channelId
     * @description
     *      GET A CHANNEL FROM CACHE
     */
    private getChannelFromCache;
    private updateChannelsList;
    private addOrUpdateChannelToCache;
    private removeChannelFromCache;
    retrieveLatests(beforeDate?: Date): Promise<any>;
    incrementInvitationCounter(): void;
    decrementInvitationCounter(): void;
    /****************************************************************/
    /*** MANAGEMENT EVENT HANDLER                                 ***/
    /****************************************************************/
    private onAvatarChange;
    private onUpdateToChannel;
    onAddToChannel(channelInfo: {
        id: string;
    }): void;
    private onRemovedFromChannel;
    private onSubscribeToChannel;
    private onUnsubscribeToChannel;
    private onDeleteChannel;
    private onUserSubscribeEvent;
    private onUserUnsubscribeEvent;
}
export { Channels as ChannelsService };
