/// <reference types="node" />
export {};
import { Conversation } from "../common/models/Conversation";
import { Logger } from "../common/Logger";
import { EventEmitter } from "events";
import { Core } from "../Core";
declare class Conversations {
    private _xmpp;
    private _rest;
    private _options;
    private _s2s;
    private _useXMPP;
    private _useS2S;
    private _contactsService;
    private _fileStorageService;
    private _fileServerService;
    private _presence;
    private _eventEmitter;
    private _logger;
    private pendingMessages;
    private _conversationEventHandler;
    private _conversationHandlerToken;
    private _conversationHistoryHandlerToken;
    conversations: Array<Conversation>;
    private _conversationServiceEventHandler;
    private _bubblesService;
    activeConversation: any;
    inCallConversations: any;
    idleConversations: any;
    involvedContactIds: any;
    involvedRoomIds: any;
    waitingBotConversations: any;
    botServiceReady: any;
    private _conversationHistoryHandler;
    private chatRenderer;
    ready: boolean;
    private readonly _startConfig;
    private conversationsRetrievedFormat;
    private nbMaxConversations;
    get startConfig(): {
        start_up: boolean;
        optional: boolean;
    };
    constructor(_eventEmitter: EventEmitter, _logger: Logger, _startConfig: any, _conversationsRetrievedFormat: any, _nbMaxConversations: any);
    start(_options: any, _core: Core): Promise<unknown>;
    stop(): Promise<unknown>;
    attachHandlers(): void;
    _onReceipt(receipt: any): void;
    /**
     * @private
     * @method
     * @instance
     * @description
     *    Allow to get the list of existing conversations from server (p2p and bubbles)
     * @return {Conversation[]} An array of Conversation object
     */
    getServerConversations(): Promise<unknown>;
    /**
     * @private
     * @method
     * @instance
     * @description
     *    Allow to create a conversations on server (p2p and bubbles)
     * @param {String} conversation of the conversation (dbId field)
     * @return {Conversation} Created conversation object
     */
    createServerConversation(conversation: any): Promise<any>;
    removeOlderConversations(conversations?: []): Promise<unknown>;
    sortFunction(aa: any, bb: any): number;
    /**
     * @private
     * @method
     * @instance
     * @description
     *    Allow to delete a conversation on server (p2p and bubbles)
     * @param {String} conversationId of the conversation (id field)
     * @return {Promise}
     */
    deleteServerConversation(conversationId: any): Promise<unknown>;
    /**
     * @private
     * @method
     * @instance
     * @description
     *    Allow to mute notification in a conversations (p2p and bubbles)
     *    When a conversation is muted/unmuted, all user's resources will receive the notification
     * @param {String} ID of the conversation (dbId field)
     * @param {Boolean} mute mutation state
     * @return {Promise}
     */
    updateServerConversation(conversationId: any, mute: any): Promise<unknown>;
    /**
     * @public
     * @method sendConversationByEmail
     * @instance
     * @description
     *    Allow to get the specified conversation as mail attachment to the login email of the current user (p2p and bubbles)
     *    can be used to backup a conversation between a rainbow user and another one, or between a user and a room,
     *    The backup of the conversation is restricted to a number of days before now. By default the limit is 30 days.
     * @param {String} ID of the conversation (dbId field)
     * @async
     * @return {Promise<Conversation[]>}
     * @fulfil {Conversation[]} - Array of Conversation object
     * @category async
     */
    sendConversationByEmail(conversationDbId: any): Promise<unknown>;
    /**
     * @public
     * @method ackAllMessages
     * @instance
     * @description
     *    Mark all unread messages in the conversation as read.
     * @param {String} ID of the conversation (dbId field)
     * @async
     * @return {Promise<Conversation[]>}
     * @fulfil {Conversation[]} - Array of Conversation object
     * @category async
     */
    ackAllMessages(conversationDbId: any): Promise<unknown>;
    /**
     * @public
     * @method getHistoryPage
     * @instance
     * @description
     *    Retrieve the remote history of a specific conversation.
     * @param {Conversation} conversation Conversation to retrieve
     * @param {number} size Maximum number of element to retrieve
     * @async
     * @return {Promise<Conversation[]>}
     * @fulfil {Conversation[]} - Array of Conversation object
     * @category async
     */
    getHistoryPage(conversation: any, size: any): any;
    /**
     * @private
     * @method
     * @instance
     */
    getOrCreateOneToOneConversation(conversationId: any, conversationDbId?: any, lastModification?: any, lastMessageText?: any, missedIMCounter?: any, muted?: any, creationDate?: any): Promise<Conversation>;
    /**
     * @public
     * @method getBubbleConversation
     * @instance
     * @description
     *    Get a conversation associated to a bubble (using the bubble ID to retrieve it)
     * @param {String} bubbleJid JID of the bubble (dbId field)
     * @param conversationDbId
     * @param lastModification
     * @param lastMessageText
     * @param missedIMCounter
     * @param noError
     * @param muted
     * @param creationDate
     * @param lastMessageSender
     * @async
     * @return {Promise<Conversation>}
     * @fulfil {Conversation} - Conversation object or null if not found
     * @category async
     */
    getBubbleConversation(bubbleJid: any, conversationDbId?: any, lastModification?: any, lastMessageText?: any, missedIMCounter?: any, noError?: any, muted?: any, creationDate?: any, lastMessageSender?: any): Promise<any>;
    /**
     * @public
     * @method sendIsTypingState
     * @instance Conversations
     * @description
     *    Switch the "is typing" state in a conversation<br>
     * @param {Conversation} conversation The conversation recipient
     * @param {boolean} status The status, true for setting "is Typing", false to remove it
     * @return a promise with no success parameter
     */
    sendIsTypingState(conversation: any, status: any): Promise<unknown>;
    /**
     * @private
     * @method
     * @instance
     * @description
     * Get a pstn conference
     */
    getRoomConferences(conversation: any): Promise<unknown>;
    /**
     * @private
     * @method
     * @instance
     * @description
     * Update a pstn conference
     */
    updateRoomConferences(): void;
    /**
     * @public
     * @method closeConversation
     * @instance
     * @description
     *    Close a conversation <br/>
     *    This method returns a promise
     * @param {Conversation} conversation The conversation to close
     * @async
     * @return {Promise}
     * @fulfil {} Return nothing in case success
     * @category async
     */
    closeConversation(conversation: any): Promise<unknown>;
    /**
     * @private
     * @method
     * @instance
     * @description
     *    Remove locally a conversation <br/>
     *    This method returns a promise
     * @param {Conversation} conversation The conversation to remove
     */
    removeConversation(conversation: any): void;
    /*********************************************************/
    /**                   MESSAGES STUFF                    **/
    /*********************************************************/
    /**
     * @private
     * @method sendFSMessage
     * @instance
     * @description
     *   Send an file sharing message
     */
    sendFSMessage(conversation: any, file: any, data: any): Promise<unknown>;
    /**
     * @public
     * @method sendExistingMessage
     * @instance
     * @param {string} data The text message to send
     * @description
     *    Send a message to this conversation
     * @return {Message} The message sent
     */
    sendExistingFSMessage(conversation: any, message: any, fileDescriptor: any): Promise<unknown>;
    /**
     * @private
     * @method
     * @instance
     * @description
     *   Send an existing file sharing message
     */
    sendEFSMessage(conversation: any, fileDescriptor: any, data: any): any;
    /**
     * @private
     * @method
     * @instance
     * @description
     *    Send a instant message to a conversation
     *    This method works for sending messages to a one-to-one conversation or to a bubble conversation<br/>
     * @param {Conversation} conversation The conversation to clean
     * @param {String} data Test message to send
     */
    sendChatMessage(conversation: any, data: any, answeredMsg: any): any;
    /**
     * SEND CORRECTED MESSAGE
     */
    /**
     * @public
     * @method sendCorrectedChatMessage
     * @instance
     * @description
     *    Send a corrected message to a conversation
     *    This method works for sending messages to a one-to-one conversation or to a bubble conversation<br/>
     *    The new message has the property originalMessageReplaced which spot on original message // Warning this is a circular depend.
     *    The original message has the property replacedByMessage  which spot on the new message // Warning this is a circular depend.
     *    Note: only the last sent message on the conversation can be changed. The connected user must be the sender of the original message.
     * @param conversation
     * @param data
     * @param origMsgId
     * @returns {Promise<String>} message the message new correction message sent. Throw an error if the send fails.
     */
    sendCorrectedChatMessage(conversation: any, data: any, origMsgId: any): Promise<any>;
    /**
     * @public
     * @since 1.58
     * @method deleteMessage
     * @instance
     * @async
     * @description
     *    Delete a message by sending an empty string in a correctedMessage
     * @param {Conversation} conversation The conversation object
     * @param {String} messageId The id of the message to be deleted
     * @return {Message} - message object with updated replaceMsgs property
     */
    deleteMessage(conversation: any, messageId: any): Promise<any>;
    /**
     *
     * @public
     * @since 1.67.0
     * @method deleteAllMessageInOneToOneConversation
     * @instance
     * @async
     * @description
     *   Delete all messages for the connected user on a one to one conversation.
     * @param {Conversation} conversation The conversation object
     * @return {Message} - message object with updated replaceMsgs property
     */
    deleteAllMessageInOneToOneConversation(conversation: any): Promise<any>;
    /**
     * @private
     * @description
     *      Store the message in a pending list. This pending list is used to wait the "_onReceipt" event from server when a message is sent.
     *      It allow to give back the status of the sending process.
     * @param conversation
     * @param message
     */
    storePendingMessage(conversation: any, message: any): void;
    /**
     * @private
     * @description
     *      delete the message in a pending list. This pending list is used to wait the "_onReceipt" event from server when a message is sent.
     *      It allow to give back the status of the sending process.
     * @param message
     */
    removePendingMessage(message: any): void;
    /**
     * @public
     * @method removeAllMessages
     * @instance
     * @description
     *    Cleanup a conversation by removing all previous messages<br/>
     *    This method returns a promise
     * @param {Conversation} conversation The conversation to clean
     * @async
     * @return {Promise}
     * @fulfil {} Return nothing in case success
     * @category async
     */
    removeAllMessages(conversation: any): Promise<unknown>;
    /**
     * @public
     * @method removeMessagesFromConversation
     * @instance
     * @description
     *    Remove a specific range of message in a conversation<br/>
     *    This method returns a promise
     * @param {Conversation} conversation The conversation to clean
     * @async
     * @return {Promise}
     * @fulfil {} Return nothing in case success
     * @category async
     */
    removeMessagesFromConversation(conversation: any, date: any, number: any): Promise<unknown>;
    /**
     * @public
     * @method getConversationById
     * @instance
     * @description
     *      Get a p2p conversation by id
     * @param {String} conversationId Conversation id of the conversation to clean
     * @return {Conversation} The conversation to retrieve
     */
    getConversationById(conversationId: any): Conversation;
    /**
     * @private
     * @method
     * @instance
     * @description
     *      Get a conversation by db id
     * @param {String} dbId db id of the conversation to retrieve
     * @return {Conversation} The conversation to retrieve
     */
    getConversationByDbId(dbId: any): Conversation;
    /**
     * @private
     * @method
     * @instance
     * @description
     *      Get a bubble conversation by bubble id
     * @param {String} bubbleId Bubble id of the conversation to retrieve
     * @return {Conversation} The conversation to retrieve
     */
    getConversationByBubbleId(bubbleId: any): Promise<Conversation>;
    /**
     * @private
     * @method
     * @instance
     * @description
     *      Get a bubble conversation by bubble id
     * @param {String} bubbleJid Bubble jid of the conversation to retrieve
     * @return {Conversation} The conversation to retrieve
     */
    getConversationByBubbleJid(bubbleJid: any): Conversation;
    /**
     * @public
     * @method getAllConversations
     * @instance
     * @description
     *    Allow to get the list of existing conversations (p2p and bubbles)
     * @return {Conversation[]} An array of Conversation object
     */
    getAllConversations(): any[];
    /**
     * @private
     * @method
     * @instance
     * @description
     *      Get all conversation
     * @return {Conversation[]} The conversation list to retrieve
     */
    getConversations(): any[];
    /**
     * @public
     * @method openConversationForContact
     * @instance
     * @description
     *    Open a conversation to a contact <br/>
     *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>
     *    This method returns a promise
     * @param {Contact} contact The contact involved in the conversation
     * @return {Conversation} The conversation (created or retrieved) or null in case of error
     */
    openConversationForContact(contact: any): Promise<Conversation>;
    /**
     * @public
     * @method openConversationForBubble
     * @since 1.65
     * @instance
     * @description
     *    Open a conversation to a bubble <br/>
     *    Create a new one if the conversation doesn't exist or reopen a closed conversation<br/>
     *    This method returns a promise
     * @param {Bubble} bubble The bubble involved in this conversation
     * @return {Conversation} The conversation (created or retrieved) or null in case of error
     */
    openConversationForBubble(bubble: any): Promise<unknown>;
    /**
     * @private
     * @method getS2SServerConversation
     * @since 1.65
     * @instance
     * @description
     *    get a conversation from id on S2S API Server.<br/>
     *    This method returns a promise
     * @param {string} conversationId The id of the conversation to find.
     * @return {Conversation} The conversation (created or retrieved) or null in case of error
     */
    getS2SServerConversation(conversationId: any): Promise<unknown>;
    /**
     * @private
     */
    onRoomChangedEvent(__event: any, bubble: any, action: any): Promise<void>;
    /**
     * @private
     */
    /**
     * @private
     */
    onRoomAdminMessageEvent(__event: any, roomJid: any, userJid: any, type: any, msgId: any): void;
    /*********************************************************************/
    /** Remove the conversation history                                 **/
    /*********************************************************************/
    /**
     * @private
     *
     */
    reinit(): Promise<unknown>;
    /*********************************************************************/
    /** BOT SERVICE IS RUNNING, CREATE ALL BOT CONVERSATIONS            **/
    /*********************************************************************/
    unlockWaitingBotConversations(isBotServiceReady?: any): void;
}
export { Conversations as ConversationsService };
