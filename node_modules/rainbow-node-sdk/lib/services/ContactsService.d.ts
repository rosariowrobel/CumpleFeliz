/// <reference types="node" />
import { Contact } from "../common/models/Contact";
import { EventEmitter } from "events";
import { Logger } from "../common/Logger";
import { Core } from "../Core";
export {};
declare class Contacts {
    private avatarDomain;
    private _xmpp;
    private _options;
    private _s2s;
    private _useXMPP;
    private _useS2S;
    private _contacts;
    private _eventEmitter;
    private _rosterPresenceQueue;
    userContact: any;
    private _rest;
    private _invitationsService;
    private _presenceService;
    private _logger;
    ready: boolean;
    private readonly _startConfig;
    get startConfig(): {
        start_up: boolean;
        optional: boolean;
    };
    constructor(_eventEmitter: EventEmitter, _http: any, _logger: Logger, _startConfig: any);
    start(_options: any, _core: Core): Promise<unknown>;
    stop(): Promise<unknown>;
    init(): Promise<unknown>;
    /**
     * @public
     * @method getDisplayName
     * @instance
     * @param {Contact} contact  The contact to get display name
     * @return {String} The contact first name and last name
     * @description
     *      Get the display name of a contact
     */
    getDisplayName(contact: any): string;
    /**
     * @public
     * @method getRosters
     * @instance
     * @description
     *      Get the list of _contacts that are in the user's network (aka rosters)
     * @async
     * @return {Promise<Array>}
     * @fulfil {ErrorManager} - ErrorManager object depending on the result (ErrorManager.getErrorManager().OK in case of success)
     * @category async
     */
    getRosters(): Promise<unknown>;
    /**
     * @public
     * @method getAll
     * @instance
     * @return {Contact[]} the list of _contacts
     * @description
     *  Return the list of _contacts that are in the network of the connected users (aka rosters)
     */
    getAll(): any;
    createEmptyContactContact(jid: any): Contact;
    getContact(jid: any, phoneNumber: any): any;
    getOrCreateContact(jid: any, phoneNumber: any): Promise<any>;
    createBasicContact(jid: any, phoneNumber?: any): Contact;
    /**
     * @public
     * @method getContactByJid
     * @instance
     * @param {string} jid The contact jid
     * @param {boolean} forceServerSearch Boolean to force the search of the _contacts informations on the server.
     * @description
     *  Get a contact by his JID by searching in the connected user _contacts list (full information) and if not found by searching on the server too (limited set of information)
     * @async
     * @return {Promise<Contact, ErrorManager>}
     * @fulfil {Contact} - Found contact or null or an error object depending on the result
     * @category async
     */
    getContactByJid(jid: any, forceServerSearch?: boolean): Promise<Contact>;
    /**
     * @public
     * @method getContactById
     * @instance
     * @param {string} id The contact id
     * @param {boolean} forceServerSearch Boolean to force the search of the _contacts informations on the server.
     * @description
     *  Get a contact by his id
     * @async
     * @return {Promise<Contact, ErrorManager>}
     * @fulfil {Contact} - Found contact or null or an error object depending on the result
     * @category async
     */
    getContactById(id: any, forceServerSearch?: boolean): Promise<Contact>;
    /**
     * @public
     * @method getContactByLoginEmail
     * @instance
     * @param {string} loginEmail The contact loginEmail
     * @description
     *  Get a contact by his loginEmail
     * @async
     * @return {Promise<Contact, ErrorManager>}
     * @fulfil {Contact} - Found contact or null or an error object depending on the result
     * @category async
     */
    getContactByLoginEmail(loginEmail: any): Promise<Contact>;
    /**
     * @public
     * @method getAvatarByContactId
     * @instance
     * @param {string} id The contact id
     * @param {string} lastAvatarUpdateDate use this field to give the stored date ( could be retrieved with contact.lastAvatarUpdateDate )
     *      if missing or null in case where no avatar available a local module file is provided instead of URL
     * @description
     *  Get a contact avatar by his contact id
     * @return {String} Contact avatar URL or file
     */
    getAvatarByContactId(id: any, lastUpdate: any): string;
    isTelJid(jid: any): boolean;
    getImJid(jid: any): any;
    getRessourceFromJid(jid: any): string;
    isUserContactJid(jid: any): boolean;
    isUserContact(contact: Contact): boolean;
    /**
     * @public
     * @method getConnectedUser
     * @instance
     * @description
     *    Get the connected user information
     * @return {Contact} Return a Contact object representing the connected user information or null if not connected
     */
    getConnectedUser(): Contact;
    /**
     * @public
     * @since 1.17
     * @method addToNetwork
     * @instance
     * @description
     *    Send an invitation to a Rainbow user for joining his network. <br>
     *    The user will receive an invitation that can be accepted or declined <br>
     *    In return, when accepted, he will be part of your network <br>
     *    When in the same company, invitation is automatically accepted (ie: can't be declined)
     * @param {Contact} contact The contact object to subscribe
     * @return {Object} A promise that contains the contact added or an object describing an error
     */
    addToNetwork(contact: Contact): Promise<unknown>;
    /**
     * @public
     * @since 1.17
     * @method addToContactsList
     * @instance
     * @description
     *    Send an invitation to a Rainbow user for joining his network. <br>
     *    The user will receive an invitation that can be accepted or declined <br>
     *    In return, when accepted, he will be part of your network <br>
     *    When in the same company, invitation is automatically accepted (ie: can't be declined)
     * @param {Contact} contact The contact object to subscribe
     * @return {Object} A promise that contains the contact added or an object describing an error
     * @category async
     */
    addToContactsList(contact: Contact): Promise<unknown>;
    /**
     * @public
     * @method removeFromNetwork
     * @since 1.69
     * @instance
     * @description
     *    Remove a contact from the list of contacts and unsubscribe to the contact's presence
     * @param {Contact} contact The contact object to unsubscribe
     * @returns {Promise} A promise that contains success code if removed or an object describing an error
     */
    removeFromNetwork(contact: any): Promise<unknown>;
    /**
     * @public
     * @since 1.64.0
     * @method getInvitationById
     * @instance
     * @description
     *    Get an invite by its id
     * @param {String} strInvitationId the id of the invite to retrieve
     * @return {Invitation} The invite if found
     */
    getInvitationById(strInvitationId: any): Promise<any>;
    /**
     * @public
     * @since 1.17
     * @method
     * @instance
     * @description
     *    Accept an invitation from an other Rainbow user to mutually join the network <br>
     *    Once accepted, the user will be part of your network. <br>
     *    Return a promise
     * @param {Invitation} invitation The invitation to accept
     * @return {Object} A promise that contains SDK.OK if success or an object that describes the error
     */
    acceptInvitation(invitation: any): Promise<unknown>;
    /**
     * @public
     * @since 1.17
     * @method
     * @instance
     * @description
     *    Decline an invitation from an other Rainbow user to mutually join the network <br>
     *    Once declined, the user will not be part of your network. <br>
     *    Return a promise
     * @param {Invitation} invitation The invitation to decline
     * @return {Object} A promise that contains SDK.OK in case of success or an object that describes the error
     */
    declineInvitation(invitation: any): Promise<unknown>;
    /**
     * @typedef {Object} joinContactsResult
     * @property {String[]} success List of succeed joined users
     * @property {String[]} failed List of failed to joined users
     */
    /**
     * @public
     * @since 1.41
     * @beta
     * @method joinContacts
     * @instance
     * @description
     *    As admin, add _contacts to a user roster
     * @param {Contact} contact The contact object to subscribe
     * @param {String[]} contactIds List of contactId to add to the user roster
     * @async
     * @return {Promise<joinContactsResult, ErrorManager>}
     * @fulfil {joinContactsResult} - Join result or an error object depending on the result
     * @category async
     */
    joinContacts(contact: Contact, contactIds: any): Promise<unknown>;
    /**
     * @private
     * @method _onRosterPresenceChanged
     * @instance
     * @param {Object} presence contains informations about contact changes
     * @description
     *      Method called when the presence of a contact changed
     */
    _onRosterPresenceChanged(presence: any): void;
    /**
     * @private
     * @method _onContactInfoChanged
     * @instance
     * @param {string} jid modified roster contact Jid
     * @description
     *     Method called when an roster user information are updated
     */
    _onContactInfoChanged(jid: any): void;
    /**
     * @private
     * @method _onUserInviteReceived
     * @instance
     * @param {Object} data contains the invitationId
     * @description
     *      Method called when an user invite is received
     */
    /**
     * @private
     * @method _onUserInviteAccepted
     * @instance
     * @param {Object} data contains the invitationId
     * @description
     *      Method called when an user invite is accepted
     */
    /**
     * @private
     * @method _onUserInviteCanceled
     * @instance
     * @param {Object} data contains the invitationId
     * @description
     *      Method called when an user invite is canceled
     */
    /**
     * @private
     * @method _onRostersUpdate
     * @instance
     * @param {Object} contacts contains a contact list with updated elements
     * @description
     *      Method called when the roster _contacts is updated
     */
    _onRostersUpdate(contacts: any): void;
}
export { Contacts as ContactsService };
