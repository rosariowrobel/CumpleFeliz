/// <reference types="node" />
export {};
import { Call } from "../common/models/Call";
import { EventEmitter } from "events";
import { Logger } from "../common/Logger";
import { Core } from "../Core";
declare class Telephony {
    private _xmpp;
    private _rest;
    private _options;
    private _s2s;
    private _useXMPP;
    private _useS2S;
    private _contacts;
    private _bubbles;
    private _profiles;
    private _eventEmitter;
    private _logger;
    private _calls;
    private voiceMail;
    private userJidTel;
    private started;
    private agentStatus;
    private voicemailNumber;
    private pbxId;
    private forwardObject;
    private nomadicObject;
    private nomadicAnswerNotTakedIntoAccount;
    private isBasicCallAllowed;
    private isSecondCallAllowed;
    private isTransferAllowed;
    private isConferenceAllowed;
    private isVMDeflectCallAllowed;
    private voiceMailFeatureEnabled;
    private isForwardEnabled;
    private isNomadicEnabled;
    private telephonyHandlerToken;
    private telephonyHistoryHandlerToken;
    startDate: any;
    private _telephonyEventHandler;
    private makingCall;
    private starting;
    private stats;
    ready: boolean;
    private readonly _startConfig;
    get startConfig(): {
        start_up: boolean;
        optional: boolean;
    };
    constructor(_eventEmitter: EventEmitter, logger: Logger, _startConfig: any);
    start(_options: any, _core: Core): Promise<unknown>;
    stop(): Promise<unknown>;
    attachHandlers(): void;
    init(): Promise<unknown>;
    /**
     * @private
     * @method onTelPresenceChange
     * @instance
     * @description
     *      Method called when receiving an update on user presence
     */
    onTelPresenceChange(__event: any, attr?: any): boolean;
    /**
     * @private
     * @method onCallUpdated
     * @instance
     * @description
     *      Method called when receiving an update on a call
     */
    onCallUpdated(callInfo: Call): void;
    /**
     * @public
     * @method isTelephonyAvailable
     * @instance
     * @description
     *    Check if the telephony service can be used or not (if the connected user has a phone monitored by a PBX)
     * @return {boolean} Return true if the telephony service is configured
     */
    isTelephonyAvailable(): any;
    /**
     * @public
     * @method getAgentVersion
     * @instance
     * @description
     *    Get the associated PBX agent version
     * @return {string} Return the version of the agent or "unknown"
     */
    getAgentVersion(): any;
    /**
     * @public
     * @method getXMPPAgentStatus
     * @instance
     * @description
     *    Get the status of the XMPP connection to the PBX Agent
     * @return {string} Return the status of the connections to the agent or "unknown"
     */
    getXMPPAgentStatus(): any;
    /**
     * @public
     * @method getPhoneAPIStatus
     * @instance
     * @description
     *    Get the status of the Phone API status for the PBX Agent
     * @return {string} Return the Phone API status for to this Agent or "unknown"
     */
    getPhoneAPIStatus(): any;
    getAgentStatus(): Promise<unknown>;
    /**
     * @private
     * @method getTelephonyState
     * @param second
     */
    getTelephonyState(second: any): Promise<unknown>;
    /**
     * @private
     * @param connectionElemObj
     */
    private createCallFromConnectionElem;
    /**
     * @private
     * @method getParticipantsFromParticipantsElem
     * @param participants
     */
    getParticipantsFromParticipantsElem(participants: any): Promise<unknown>;
    /**
     * @public
     * @method getVoiceMessageCounter
     * @description
     *      Get the number of voice message
     * @return {Promise<integer>} Return resolved promise if succeed with the number of messages, and a rejected else.
     */
    getVoiceMessageCounter(): Promise<unknown>;
    /*********************************************************/
    /**                   CALL HANDLERS                     **/
    /*********************************************************/
    /**
     * @public
     * @method getCallToHangOut
     * @description
     *      Get the call which can be hang out
     * @return {Call} The call with the ability to be hang out.
     */
    getCallToHangOut(): any;
    /**
     * @public
     * @method getActiveCall
     * @description
     *      get the active call
     * @return {Call} The active call
     */
    getActiveCall(): any;
    /**
     * @public
     * @method getActiveCalls
     * @description
     *      get active calls
     * @return {Call} The active call
     */
    getActiveCalls(): any[];
    /**
     * @public
     * @method getCalls
     * @description
     *      get calls
     * @return {Call} The calls
     */
    getCalls(): any[];
    /**
     * @public
     * @method getCallsSize
     * @description
     *      get calls tab size. Warning do not use length on the getCalls method result because it is the last index id +1
     * @return {Call} The calls tab size
     */
    getCallsSize(): number;
    /**
     * @private
     * @param {Array} tab The tab which need to be sized
     */
    getTabSize(tab: any): number;
    /**
     * @public
     * @method getActiveCall
     * @param {Contact} contact The contact with an active call with us.
     * @description
     *      get the active call for a contact
     * @return {Call} The active call
     */
    getActiveCallsForContact(contact: any): any[];
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method makeCall
     * @instance
     * @description
     *    Call a number <br/>
     *    Contacts and numbers are allowed
     *    Return a promise
     * @param {Contact} contact - contact object that you want to call
     * @param {String} phoneNumber The number to call
     * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call
     * @return {Promise<Call>} Return a promise with the call created
     */
    makeCall(contact: any, phoneNumber: any, correlatorData: any): Promise<unknown>;
    /**
     * @private
     * @method makeSimpleCall
     * @param contact
     * @param phoneNumber
     * @param correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call
     */
    private makeSimpleCall;
    /**
     * @private
     * @method makeConsultationCall
     * @param contact
     * @param phoneNumber
     * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call
     * @param callId
     */
    private makeConsultationCall;
    /**
     * @public
     * @method makeCall
     * @instance
     * @description
     *    Call a number <br/>
     *    Return a promise
     * @param {String} phoneNumber The number to call
     * @param {String} correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call
     * @return {Promise<Call>} Return a promise with the call created
     */
    makeCallByPhoneNumber(phoneNumber: any, correlatorData: any): Promise<unknown>;
    /**
     * @private
     * @method getPhoneInfo
     * @param contact
     * @param phoneNumber
     * @param correlatorData contains User-to-User information to be sent out as a SIP header via underlying PBX trunk for a given call
     */
    private getPhoneInfo;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method releaseCall
     * @instance
     * @description
     *    Release a call <br/>
     *    Return a promise
     * @param {Call} call The call to release
     * @return {Promise<Call>} Return a promise with the call released
     */
    releaseCall(call: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method answerCall
     * @instance
     * @description
     *    Answer a call <br/>
     *    Return a promise
     * @param {Call} call The call to answer
     * @return {Promise<Call>} Return a promise with the answered call.
     */
    answerCall(call: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method holdCall
     * @instance
     * @description
     *    Hold a call <br/>
     *    Return a promise
     * @param {Call} call The call to hold
     * @return {Call} Return a promise with the held call.
     */
    holdCall(call: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method retrieveCall
     * @instance
     * @description
     *    Retrieve a call <br/>
     *    Return a promise
     * @param {Call} call The call to retrieve
     * @return {Promise<Call>} Return a promise with the call retrieved
     */
    retrieveCall(call: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method deflectCallToVM
     * @instance
     * @description
     *    Deflect a call to the voice mail <br/>
     *    Return a promise
     * @param {Call} call The call to deflect
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    deflectCallToVM(call: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method deflectCall
     * @instance
     * @description
     *    Deflect a call to an other telephone number<br/>
     *    Return a promise
     * @param {Call} call The call to deflect
     * @param {Object} callee The callee phone number informations where the call shopuld be deflecte'd.
     * @param {string} callee.calleeExtNumber : The phone number where the call is deflected, the format could be anything the user can type, it will be transformed in E164 format.,
     * @param {string} callee.calleeIntNumber : Internal number if available,
     * @param {string} callee.calleePbxId : The pbx id if available,
     * @param {string} [callee.calleeShortNumber] : Short number,
     * @param {string} [callee.calleeDisplayName] : The displayed name,
     * @param {string} [callee.calleeCountry] : The contry whe the call will be deflected.
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    deflectCall(call: any, callee: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method transfertCall
     * @instance
     * @description
     *    Transfer a held call to the active call <br/>
     *    User should have transfer rights <br/>
     *    Return a promise
     * @param {Call} activeCall The active call
     * @param {Call} heldCall The held call to transfer to the activeCall
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    transfertCall(activeCall: any, heldCall: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method conferenceCall
     * @instance
     * @description
     *    Create a conference with a held call and the active call <br/>
     *    User should have conference rights <br/>
     *    Return a promise
     * @param {Call} activeCall The active call
     * @param {Call} heldCall The held call to transfer to the activeCall
     * @return {Promise} Return a resolved promise .
     */
    conferenceCall(activeCall: any, heldCall: any): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method forwardToDevice
     * @instance
     * @description
     *    Activate the forward to a number <br/>
     *    Return a promise
     * @param {String} phoneNumber The number to call
     * @return {Promise} Return a promise resolved.
    */
    forwardToDevice(phoneNumber: any): Promise<unknown>;
    /**
     * @public
     * @method forwardToVoicemail
     * @instance
     * @description
     *    Activate the forward to VM <br/>
     *    Return a promise
     * @return {Promise} Return a promise resolved.

     */
    forwardToVoicemail(): Promise<unknown>;
    /**
     * @public
     * @method cancelForward
     * @instance
     * @description
     *    Cancel the forward <br/>
     *    Return a promise
     * @return {Promise<Call>} Return a promise with the canceled forward call.
     */
    cancelForward(): Promise<unknown>;
    getForwardStatus(): Promise<unknown>;
    /*************************************************************/
    /*************************************************************/
    nomadicLogin(phoneNumber: any, NotTakeIntoAccount?: any): Promise<unknown>;
    getNomadicStatus(): Promise<unknown>;
    /**
     * @private
      * @param response
     */
    updateNomadicData(response: any): Promise<void>;
    getNomadicObject(): any;
    getNomadicDestination(): any;
    /*************************************************************/
    /*************************************************************/
    /**
     * @public
     * @method sendDtmf
     * @description
     *      send dtmf to the remote party
     * @param {string} connectionId
     * @param {string} dtmf
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    sendDtmf(connectionId: any, dtmf: any): Promise<unknown>;
    /**
     * @private
     * @method clearCall
     * @param Call call the call to reset.
     * @return nothing.
     */
    private clearCall;
    private startAsPhoneNumber;
    /**
     * @private
     * @method getOrCreateCall
     * @param status
     * @param connectionId
     * @param deviceType
     * @param contact
     */
    getOrCreateCall(status: any, connectionId: any, deviceType: any, contact?: any): Call;
    /**
     * @private
     * @param callId
     * @description
     *      GET A CALL FROM CACHE
     */
    private getCallFromCache;
    addOrUpdateCallToCache(call: any): Call;
    private removeCallFromCache;
    /**
     * @public
     * @method logon
     * @param {String} endpointTel The endpoint device phone number.
     * @param {String} agentId optionnel CCD Agent identifier (agent device number).
     * @param {String} password optionnel Password or authorization code.
     * @param {String} groupId optionnel CCD Agent's group number
     * @description
     *      This api allows an CCD Agent to logon into the CCD system.
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    logon(endpointTel: any, agentId: any, password: any, groupId: any): Promise<unknown>;
    /**
     * @public
     * @method logoff
     * @param {String} endpointTel The endpoint device phone number.
     * @param {String} agentId optionnel CCD Agent identifier (agent device number).
     * @param {String} password optionnel Password or authorization code.
     * @param {String} groupId optionnel CCD Agent's group number
     * @description
     *      This api allows an CCD Agent logoff logon from the CCD system.
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    logoff(endpointTel: any, agentId: any, password: any, groupId: any): Promise<unknown>;
    /**
     * @public
     * @method withdrawal
     * @param {String} agentId optionnel CCD Agent identifier (agent device number).
     * @param {String} groupId optionnel CCD Agent's group number
     * @param {String} status optionnel Used to deactivate the withdrawal state. Values: 'on', 'off'; 'on' is optional.
     * @description
     *      This api allows an CCD Agent to change to the state 'Not Ready' on the CCD system. When the parameter 'status' is passed and has the value 'off', the state is changed to 'Ready'
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    withdrawal(agentId: any, groupId: any, status: any): Promise<unknown>;
    /**
     * @public
     * @method wrapup
     * @param {String} agentId CCD Agent identifier (agent device number).
     * @param {String} groupId CCD Agent's group number
     * @param {String} password optionnel Password or authorization code.
     * @param {String} status optionnel Used to deactivate the WrapUp state. Values: 'on', 'off'; 'on' is optional.
     * @description
     *      This api allows an CCD Agent to change to the state Working After Call in the CCD system. When the parameter 'status' is passed and has the value 'off', the state is changed to 'Ready'.
     * @return {Promise} Return resolved promise if succeed, and a rejected else.
     */
    wrapup(agentId: any, groupId: any, password: any, status: any): Promise<unknown>;
}
export { Telephony as TelephonyService };
