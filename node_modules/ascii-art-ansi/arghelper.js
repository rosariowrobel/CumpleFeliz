var dyncb = function(originalArgs, extraFns){
    var data = {};
    //todo: support extraFns as a number
    data.args = Array.prototype.slice.call(originalArgs);
    if(extraFns){
        var extras;
        if(typeof data.args[data.args.length-extraFns.length-1] === 'function'){
            data.extras = data.args.slice(data.args.length-extraFns.length-1, data.args[data.args.length-1])
            data.args.splice(data.args.length-extraFns.length-1, extraFns.length);
        }else{
            if(typeof data.args[data.args.length-extraFns.length] !== 'function'){
                throw new Error('Expected Fns not found: '+extraFns.join(', '));
            }
            data.extras = data.args.slice(data.args.length-extraFns.length, data.args[data.args.length])
            data.args.splice(data.args.length-extraFns.length, extraFns.length);
        }
    }
    console.log('$$$$', typeof data.args[data.args.length-1]);
    if(typeof data.args[data.args.length-1] === 'function'){
        data.handlerType = 'callback';
        data.asyncReturn = data.args.pop();
        data.syncReturn = function(){ };
    }else{ //promise support
        data.handlerType = 'promise';
        var doResolve;
        var doError;
        var p = new Promise(function(resolve, reject){
            doResolve = resolve;
            doError = reject;
        });
        data.syncReturn = function(){  return p };
        data.asyncReturn = function(){
            var args = Array.prototype.slice.call(originalArgs);
            doResolve.apply(doResolve, args);
        }
    }
    console.log(data)
    return data;
}

var dynargs = function(originalArgs, type){ //like the spread operator + async support
    var data = {}
    switch(type){
        case 'async-iterator':
            data = dyncb(originalArgs, ['iterator']);
            break;
        case 'iterator':
            if(!originalArgs[originalArgs.length-1] !== 'function'){
                throw new Error('Expected iterator, not found.')
            }
            data.iterator = originalArgs.pop();
            data.args = originalArgs;
            data.syncReturn = function(){
                return data.result;
            };
            break;
        case 'async':
            data = dyncb(originalArgs);

    }
    return data;
}

var width = function(model){
    var w = 0;
    var result = 0;
    AsciiArt.Ansi.map(model, function(c){
        if(c === "\n"){
            if(w > result){
                result = w;
            }
            w=0;
        }else w++;
    });
    return result;
}

var height = function(model){
    var result = 0;
    AsciiArt.Ansi.strip(model).split('').map(function(c){
        if(c === "\n") result++;
    });
    return result;
}

var spaces = function(n, r, lines){
    console.log('#', n, r, lines)
    var result = '';
    for(var lcv=0; lcv < n; lcv++){
        result += '@';
        //result += undefined;
    }
    if(r){
        var s = result;
        result = '';
        for(var lcv=0; lcv < r; lcv++){
            result += s;
            if(lines) result += "\n";
        }
    }
    return result;
}

var normalize = function(target, model, offsetX, offsetY){
    var offX = offsetX?offsetX:0;
    var offY = offsetY?offsetY:0;
    var h1 = height(target);
    var w1 = width(target);
    var h2 = height(model);
    var w2 = width(model);
    var dh = h2 - h1 - offY;
    var dw = w2 - w1 - offX;
    var result = '';
    if(offY){
        result += spaces(w2, offY, true);
    }
    if(offX){
        result += spaces(offX);
    }
    AsciiArt.Ansi.map(target, function(chr, styles, p, pos, shortCircuit){
        if(chr == "\n" ){
            result += spaces(dw)+"\n"+spaces(offX);
        }else{
            result += styles.map(function(style){
                return '\033['+style+'m'
            }) + chr;
        }
    }, true);
    if(dh > 0){
        result += spaces(w2, dh, true);
    }
    return result;
}
