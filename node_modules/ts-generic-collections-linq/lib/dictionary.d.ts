import { IEnumerable, IComparer, IEqualityComparer } from './interfaces';
import { Group } from './common';
export interface IDictionary<TKey, TValue> extends IEnumerable<KeyValuePair<TKey, TValue>> {
    add(key: TKey, value: TValue): void;
    addRange(items: KeyValuePair<TKey, TValue>[]): void;
    remove(predicate: (item: KeyValuePair<TKey, TValue>) => boolean): void;
    clear(): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    tryGetValue(key: TKey): TValue;
}
export declare class Dictionary<TKey, TValue> implements IDictionary<TKey, TValue> {
    private list;
    constructor(list?: Array<KeyValuePair<TKey, TValue>>);
    add(key: TKey, value: TValue): void;
    addRange(items: KeyValuePair<TKey, TValue>[]): void;
    clear(): void;
    remove(predicate: (item: KeyValuePair<TKey, TValue>) => boolean): void;
    containsKey(key: TKey): boolean;
    containsValue(value: TValue): boolean;
    tryGetValue(key: TKey): TValue;
    asEnumerable(): IEnumerable<KeyValuePair<TKey, TValue>>;
    readonly length: number;
    elementAt(index: number): KeyValuePair<TKey, TValue>;
    any(predicate?: (item: KeyValuePair<TKey, TValue>) => boolean): boolean;
    all(predicate?: (item: KeyValuePair<TKey, TValue>) => boolean): boolean;
    single(predicate?: (item: KeyValuePair<TKey, TValue>) => boolean): KeyValuePair<TKey, TValue>;
    first(predicate?: (item: KeyValuePair<TKey, TValue>) => boolean): KeyValuePair<TKey, TValue>;
    last(predicate: (item: KeyValuePair<TKey, TValue>) => boolean): KeyValuePair<TKey, TValue>;
    singleOrDefault(predicate: (item: KeyValuePair<TKey, TValue>) => boolean): KeyValuePair<TKey, TValue>;
    firstOrDefault(predicate: (item: KeyValuePair<TKey, TValue>) => boolean): KeyValuePair<TKey, TValue>;
    lastOrDefault(predicate: (item: KeyValuePair<TKey, TValue>) => boolean): KeyValuePair<TKey, TValue>;
    where(predicate: (item: KeyValuePair<TKey, TValue>) => boolean): IDictionary<TKey, TValue>;
    select<TResult>(predicate: (item: KeyValuePair<TKey, TValue>) => TResult): IEnumerable<TResult>;
    forEach(predicate: (item: KeyValuePair<TKey, TValue>) => void): void;
    toArray(): Array<KeyValuePair<TKey, TValue>>;
    join<TOuter, TMatch, TResult>(outer: IEnumerable<TOuter>, conditionInner: (item: KeyValuePair<TKey, TValue>) => TMatch, conditionOuter: (item: TOuter) => TMatch, select: (x: KeyValuePair<TKey, TValue>, y: TOuter) => TResult, leftJoin?: boolean): IEnumerable<TResult>;
    groupBy(predicate: (item: KeyValuePair<TKey, TValue>) => Array<any>): IEnumerable<Group<KeyValuePair<TKey, TValue>>>;
    orderBy(comparer: IComparer<KeyValuePair<TKey, TValue>>): IEnumerable<KeyValuePair<TKey, TValue>>;
    distinct(comparer: IEqualityComparer<KeyValuePair<TKey, TValue>>): IEnumerable<KeyValuePair<TKey, TValue>>;
    union(list: IEnumerable<KeyValuePair<TKey, TValue>>): IDictionary<TKey, TValue>;
    skip(no: number): IDictionary<TKey, TValue>;
    take(no: number): IDictionary<TKey, TValue>;
    sum(predicate: (item: KeyValuePair<TKey, TValue>) => number): number;
    avg(predicate: (item: KeyValuePair<TKey, TValue>) => number): number;
    min(predicate: (item: KeyValuePair<TKey, TValue>) => number): number;
    max(predicate: (item: KeyValuePair<TKey, TValue>) => number): number;
    count(predicate?: (item: KeyValuePair<TKey, TValue>) => boolean): number;
}
export declare class KeyValuePair<TKey, TValue> {
    key: TKey;
    value: TValue;
    constructor(key: TKey, value: TValue);
}
